# AIdea Lab 리팩토링 및 아키텍처 업데이트: 상세 구현 계획

**최상위 목표:** 기존 AIdea Lab의 코드베이스를 안정적으로 리팩토링하고, "'통합 아이디어 문서' 중심의 반복적 개선 워크플로우" 아키텍처를 성공적으로 도입하여, 사용자가 아이디어를 제시하면 페르소나들이 효과적으로 협업하여 최선의 아이디어를 도출하는 시스템 구축.

**사전 준비:**
*   Git 브랜치 생성 (예: `refactor/phase1-ui-separation`)
*   기존 코드베이스 전체 백업
*   개발 환경 일치 확인 (`requirements.txt`)

---

**Phase 1: UI 및 상태 관리 집중 리팩토링 (`src/ui/app.py` 분해)**

**목표:** `app.py`의 복잡성을 낮추고, UI, 상태 관리, ADK 호출 로직을 분리하여 모듈성을 높인다. 현재 기능은 유지하면서 구조를 개선한다.

**단계 1.1: `AppStateManager` 클래스 분리 및 강화**
*   **지침:**
    1.  `src/ui/` 디렉토리 내에 `state_manager.py` 파일을 생성합니다.
    2.  `src/ui/app.py`에 정의된 `AppStateManager` 클래스 전체를 `src/ui/state_manager.py`로 이동시킵니다.
    3.  `src/ui/app.py`에서 `from .state_manager import AppStateManager`를 통해 임포트하도록 수정합니다.
    4.  `src/ui/app.py` 파일 하단에 정의된 전역 함수들 (`initialize_session_state`, `restart_session`, `add_message`, `process_text_for_display`, `show_system_message`)을 `AppStateManager` 클래스의 정적 메서드(static methods) 또는 인스턴스 메서드로 통합합니다.
    5.  `src/ui/app.py` 내에서 이 전역 함수들을 호출하던 모든 부분을 `AppStateManager.메서드명()` 형태로 변경합니다.
*   **검증 테스트:**
    *   애플리케이션을 실행했을 때, 기존과 동일하게 환영 메시지가 표시되고, 아이디어 입력 UI가 정상적으로 나타나는지 확인합니다.
    *   간단한 아이디어를 입력하고 1단계 분석을 실행했을 때, 기존과 동일하게 각 페르소나의 응답이 채팅 UI에 순차적으로 표시되는지 확인합니다. (기능 변경 없음 확인)
    *   "새 아이디어 분석" 버튼 등이 정상적으로 작동하여 세션 상태가 초기화되는지 확인합니다.

**단계 1.2: `AppStateManager`를 통한 `st.session_state` 접근 일원화**
*   **지침:**
    1.  `src/ui/app.py` (및 리팩토링 과정에서 생성될 다른 UI 관련 파일들)에서 `st.session_state[...]` 또는 `st.session_state.get(...)`을 사용하여 직접 Streamlit 세션 상태에 접근하는 모든 코드를 찾습니다.
    2.  이러한 직접 접근 코드들을 `AppStateManager.get_state('키', 기본값)` 또는 `AppStateManager.set_state('키', 값)` 메서드 호출로 모두 변경합니다.
    3.  `AppStateManager` 내부에 `get_state`와 `set_state` 메서드가 없다면 이를 구현합니다. (이미 `AppStateManager`에 해당 기능이 있다면 이 단계는 검토 및 확인으로 대체)
*   **검증 테스트:**
    *   단계 1.1의 검증 테스트를 다시 수행하여 모든 기능이 여전히 정상적으로 작동하는지 확인합니다. (직접 접근을 메서드 호출로 변경해도 기능상 변화 없음 확인)
    *   특히 모델 변경, 아이디어 입력, 추가 정보 입력/저장 등 `st.session_state`를 많이 사용하는 기능들이 문제없이 작동하는지 집중적으로 테스트합니다.

**단계 1.3: ADK 연동 로직 캡슐화 (`adk_controller.py` 생성)**
*   **지침:**
    1.  `src/ui/` 디렉토리 내에 `adk_controller.py` 파일을 생성합니다.
    2.  `AdkController` 클래스를 정의합니다. 이 클래스는 생성자에서 `SessionManager` 인스턴스를 인자로 받도록 합니다.
    3.  `src/ui/app.py`의 `_run_phase1_analysis` 함수와 `_run_phase2_discussion` 함수 (및 이 함수들이 호출하는 하위 비동기 함수들) 내에서 ADK `Runner`를 생성하고, 에이전트를 실행하며, 이벤트 스트림을 처리하는 핵심 로직을 `AdkController` 클래스의 메서드(예: `async execute_phase1_workflow(...)`, `async execute_phase2_facilitator(...)`, `async execute_phase2_persona(...)`)로 이동시킵니다.
    4.  이 메서드들은 필요한 파라미터(예: `session_id`, `input_content`, 실행할 `agent` 객체)를 받고, 실행 결과(예: 처리된 응답 리스트, 다음 상태 정보)를 반환하도록 설계합니다.
    5.  `src/ui/app.py`에서는 `st.session_state`에 저장된 `SessionManager` 인스턴스를 사용하여 `AdkController` 인스턴스를 생성하고, 이 컨트롤러의 메서드를 호출하여 ADK 에이전트를 실행하도록 수정합니다. `app.py`는 ADK 실행의 세부 사항을 직접 알 필요가 없어집니다.
*   **검증 테스트:**
    *   1단계 분석 전체 워크플로우와 2단계 토론(가능하다면 간단한 시나리오)이 기존과 동일하게 UI에 표시되고, `session.state`에 결과가 올바르게 저장되는지 확인합니다.
    *   ADK 관련 로직이 `AdkController`로 옮겨간 후에도 기능상 변화가 없는지 확인합니다.
    *   오류 발생 시(예: API 키 문제) 기존과 유사한 방식으로 사용자에게 피드백이 전달되는지 확인합니다.

**단계 1.4: UI 렌더링 로직 분리 (`views.py` 또는 `ui_renderer.py` 생성)**
*   **지침:**
    1.  `src/ui/` 디렉토리 내에 `views.py` (또는 `ui_renderer.py`) 파일을 생성합니다.
    2.  `src/ui/app.py`의 `main()` 함수 내에서 `st.session_state.analysis_phase` 값에 따라 분기되어 각기 다른 UI 요소(버튼, 입력 필드, 텍스트, 스피너 등)를 렌더링하는 코드 블록들을 식별합니다.
    3.  이러한 각 UI 상태별 렌더링 로직을 `views.py` 내의 별도 함수(예: `render_idle_view(state_manager)`, `render_phase1_pending_view(state_manager)`, `render_phase1_complete_view(state_manager, adk_controller)`, `render_user_input_view(state_manager, prompt_message)`)로 분리합니다. 각 뷰 함수는 필요한 상태 정보나 컨트롤러 객체를 인자로 받을 수 있습니다.
    4.  `src/ui/app.py`의 `main()` 함수는 매우 간결해져야 하며, 주로 `AppStateManager`를 통해 현재 상태를 가져오고, 해당 상태에 맞는 뷰 함수를 `views.py`에서 호출하는 역할만 수행하도록 합니다.
*   **검증 테스트:**
    *   애플리케이션의 모든 화면 전환(아이디어 입력 전, 분석 중, 1단계 완료, 2단계 사용자 입력 대기, 2단계 완료 등)이 기존과 동일하게 부드럽게 이루어지는지 확인합니다.
    *   각 화면에 표시되는 버튼, 텍스트, 입력 필드 등이 정확히 렌더링되는지 확인합니다.
    *   UI 요소와 연결된 콜백 함수들이 `AppStateManager` 또는 `AdkController`의 적절한 메서드를 호출하여 기능이 정상 작동하는지 확인합니다.

**단계 1.5: (선택적) 공통 UI 컴포넌트 분리 (`components.py` 생성)**
*   **지침:**
    1.  `src/ui/` 디렉토리 내에 `components.py` 파일을 생성합니다.
    2.  여러 뷰에서 반복적으로 사용되는 UI 구성 로직(예: 채팅 메시지 리스트 렌더링, 특정 형태의 버튼 그룹 등)이 있다면, 이를 `components.py` 내의 재사용 가능한 함수로 만듭니다.
    3.  `views.py` 등에서 이 공통 컴포넌트 함수를 호출하여 사용합니다.
*   **검증 테스트:**
    *   공통 컴포넌트를 사용하는 모든 UI 부분이 기존과 동일하게 표시되고 작동하는지 확인합니다.

---

**Phase 2: 새로운 아키텍처 도입 준비**

**목표:** "'통합 아이디어 문서' 중심 워크플로우"를 도입하기 위한 데이터 구조 및 핵심 컨트롤러의 기본 틀을 마련한다.

**단계 2.1: "통합 아이디어 문서" 데이터 구조 정의**
*   **지침:**
    1.  `src/core/` 디렉토리(신규 생성) 내에 `idea_document_schema.py` (또는 유사한 이름) 파일을 생성합니다.
    2.  "통합 아이디어 문서"의 초기 JSON 스키마 또는 Python Pydantic 모델을 정의합니다. (예: `document_id`, `title`, `initial_prompt`, `user_info`, `sections` (딕셔너리), `version`, `workshop_log` 등).
    3.  `sections` 내부에는 아이디어의 각 측면(예: `problem_definition`, `target_audience`, `core_features`, `revenue_model`, `comments`)을 위한 구조를 정의합니다.
*   **검증 테스트:**
    *   정의된 스키마/모델이 예상하는 데이터를 올바르게 표현할 수 있는지 간단한 인스턴스를 만들어 확인합니다.
    *   Pydantic 모델을 사용했다면, 유효성 검사 기능이 정상 작동하는지 확인합니다.

**단계 2.2: `SessionManager` 또는 `AppStateManager`에 "통합 아이디어 문서" 관리 기능 추가**
*   **지침:**
    1.  `src/ui/state_manager.py` (또는 `src/session_manager.py`의 ADK 세션 상태 관련 부분)에 "통합 아이디어 문서"를 `session.state` (또는 `st.session_state`)에 초기화하는 함수를 추가합니다. (예: `initialize_idea_document(session_id, initial_idea_data)`).
    2.  "통합 아이디어 문서" 내의 특정 경로(예: `idea_document.sections.revenue_model.content`)에 값을 안전하게 읽고 쓰는 유틸리티 함수를 추가합니다. (딕셔너리 경로 접근 헬퍼)
*   **검증 테스트:**
    *   초기화 함수 호출 시 `session.state` (또는 `st.session_state`)에 정의된 스키마대로 "통합 아이디어 문서"가 생성되는지 확인합니다.
    *   읽기/쓰기 유틸리티 함수가 중첩된 경로에 대해 정확하게 작동하는지 단위 테스트를 작성하거나 수동으로 검증합니다.

**단계 2.3: "워크숍 매니저 에이전트" 기본 틀 생성**
*   **지침:**
    1.  `src/agents/` 디렉토리 내에 `workshop_manager_agent.py` 파일을 생성합니다.
    2.  ADK `LlmAgent`를 상속받는 `WorkshopManagerAgent` 클래스의 기본 구조를 작성합니다.
    3.  `InstructionProvider`를 사용하여 간단한 초기 프롬프트를 정의합니다. (예: "당신은 아이디어 워크숍 매니저입니다. 현재 아이디어 문서를 분석하고 다음 단계를 지시하세요.")
    4.  워크숍 매니저가 출력할 JSON 지시사항의 기본 스키마(예: `next_round_goal`, `assignments`, `request_to_user`)를 주석 등으로 명시합니다.
    5.  `output_key`를 설정합니다. (예: `"workshop_manager_decision"`)
*   **검증 테스트:**
    *   `WorkshopManagerAgent` 인스턴스가 정상적으로 생성되는지 확인합니다.
    *   (아직 실행 로직은 없으므로) 프롬프트가 기본적으로 구성되는지 간단히 확인할 수 있습니다.

---

**Phase 3: "통합 아이디어 문서" 중심 워크플로우 구현**

**목표:** 기존 1, 2단계 로직을 "'통합 아이디어 문서' 중심의 반복적 개선 워크플로우"로 대체한다.

**단계 3.1: 워크숍 매니저 에이전트의 핵심 로직 및 프롬프트 상세 구현**
*   **지침:**
    1.  `WorkshopManagerAgent`의 `InstructionProvider`를 고도화합니다. "통합 아이디어 문서"(`state.idea_document`) 내용을 입력받아 분석하고, 다음 라운드 목표, 참여할 페르소나, 각 페르소나에게 전달할 구체적인 작업 지시(참조할 문서 섹션 경로 포함)를 JSON 형식으로 생성하도록 LLM 프롬프트를 상세하게 설계합니다.
    2.  의견 충돌 시 중재 방안, 사용자 개입 요청 조건 등을 프롬프트에 포함합니다.
*   **검증 테스트:**
    *   다양한 "통합 아이디어 문서" 상태(초기, 중간, 거의 완성)를 시뮬레이션하여 `WorkshopManagerAgent`를 (격리된 환경에서 `AdkController`를 통해) 실행했을 때, 의도한 대로 다음 라운드 목표와 작업 할당 JSON이 생성되는지 확인합니다.
    *   생성된 JSON이 미리 정의한 스키마를 준수하는지 확인합니다.

**단계 3.2: 페르소나 에이전트 수정 (새로운 워크플로우에 맞게)**
*   **지침:**
    1.  기존 페르소나 에이전트들(`MarketerPersonaAgent`, `CriticPersonaAgent`, `EngineerPersonaAgent`)의 `InstructionProvider`를 수정합니다.
    2.  프롬프트는 워크숍 매니저로부터 `session.state`를 통해 전달받은 작업 지시(`state.current_task_instruction_for_XYZ`)와 "통합 아이디어 문서"의 지정된 섹션 내용(`state.idea_document.sections.some_section...`)을 컨텍스트로 받도록 합니다.
    3.  페르소나의 LLM 출력은 "통합 아이디어 문서"의 특정 부분에 대한 수정 제안, 새로운 내용 추가, 또는 코멘트 형식의 텍스트가 되도록 유도합니다.
    4.  각 페르소나 에이전트의 `output_key` (예: `"marketer_contribution"`)를 통해 이 텍스트 결과가 반환되도록 합니다.
*   **검증 테스트:**
    *   워크숍 매니저가 생성한 작업 지시와 문서 일부를 컨텍스트로 주었을 때, 각 페르소나가 해당 작업에 맞는 분석 결과/제안을 텍스트로 생성하는지 확인합니다.

**단계 3.3: UI 컨트롤러의 메인 워크플로우 로직 변경**
*   **지침:**
    1.  `src/ui/app.py` (또는 분리된 `workshop_flow_manager.py`)의 메인 로직을 수정하여, 기존 1, 2단계 실행 로직을 새로운 라운드 기반 워크플로우로 대체합니다.
    2.  워크플로우:
        a.  워크숍 매니저 에이전트 실행 (`AdkController` 사용).
        b.  반환된 JSON(`state.workshop_manager_decision`) 파싱.
        c.  JSON 지시에 따라 각 페르소나에게 작업 할당:
            i.  `session.state`에 페르소나별 작업 지시 및 컨텍스트 경로 저장.
            ii. 해당 페르소나 에이전트 실행 (`AdkController` 사용).
            iii. 페르소나의 결과(`state.persona_X_contribution`)를 가져와 "통합 아이디어 문서"(`state.idea_document`)의 적절한 위치에 업데이트/병합하는 로직 수행. (이 병합 로직이 중요)
        d.  모든 페르소나 작업 완료 후 다시 (a)로 돌아가 워크숍 매니저 실행 (라운드 반복).
        e.  워크숍 매니저가 사용자 개입을 요청하면, UI에 해당 질문을 표시하고 사용자 입력을 받아 `session.state`에 저장 후 워크숍 매니저에게 전달.
        f.  워크숍 매니저가 종료를 결정하면 워크숍 종료.
*   **검증 테스트:**
    *   사용자가 아이디어를 입력하면, 워크숍 매니저가 첫 라운드를 지시하고, 지정된 페르소나가 작업을 수행하며, 그 결과가 "통합 아이디어 문서"에 반영되는 전체 흐름을 테스트합니다.
    *   몇 차례 라운드가 반복되면서 "통합 아이디어 문서"가 점진적으로 발전하는지 확인합니다.
    *   사용자 개입 요청 및 응답 처리가 정상적으로 이루어지는지 확인합니다.

**단계 3.4: "통합 아이디어 문서" 시각화 UI 개선**
*   **지침:**
    1.  `src/ui/views.py` (또는 관련 UI 모듈)에서 "통합 아이디어 문서"(`state.idea_document`)의 내용을 사용자에게 효과적으로 보여주는 UI를 구현/개선합니다.
    2.  문서의 구조(섹션, 하위 섹션), 내용, 코멘트, 변경 이력(간단한 형태) 등을 명확하게 시각화합니다.
    3.  사용자가 문서를 쉽게 탐색하고 이해할 수 있도록 합니다.
*   **검증 테스트:**
    *   워크숍이 진행됨에 따라 "통합 아이디어 문서"가 업데이트될 때마다 UI에도 해당 변경 사항이 정확하고 보기 좋게 반영되는지 확인합니다.

---

**Phase 4: 테스트, 최적화 및 안정화**

**목표:** 새로운 아키텍처가 안정적으로 작동하고, 성능 및 사용자 경험을 개선한다.

**단계 4.1: 통합 시나리오 테스트 및 예외 처리 강화**
*   **지침:**
    1.  다양한 종류의 아이디어, 사용자 입력, 페르소나 상호작용 시나리오를 가정하여 엔드투엔드 테스트를 수행합니다.
    2.  LLM 응답이 예상과 다르거나(예: JSON 형식 오류), 특정 페르소나 작업이 실패하는 등 예외 상황에 대한 오류 처리 로직을 강화하고, 사용자에게 적절한 피드백을 제공하도록 합니다.
*   **검증 테스트:**
    *   의도적으로 잘못된 입력을 주거나 예외 상황을 유도하여 시스템이 우아하게 대처하는지 확인합니다.
    *   장시간 사용 또는 복잡한 상호작용에도 시스템이 안정적으로 유지되는지 테스트합니다.

**단계 4.2: 프롬프트 튜닝 및 LLM 응답 품질 지속 개선**
*   **지침:**
    1.  워크숍 매니저 및 각 페르소나 에이전트의 프롬프트를 실제 사용 사례를 통해 얻은 피드백을 바탕으로 지속적으로 수정하고 개선하여, LLM 응답의 정확성, 일관성, 유용성을 높입니다.
*   **검증 테스트:**
    *   여러 아이디어에 대해 워크숍을 진행시켜보고, 생성되는 "통합 아이디어 문서"의 품질과 페르소나들의 기여도를 평가합니다.
    *   사용자(또는 내부 테스터)로부터 결과물에 대한 만족도 피드백을 받습니다.

**단계 4.3: 컨텍스트 관리 전략 최적화**
*   **지침:**
    1.  "통합 아이디어 문서"가 매우 커지거나, 특정 페르소나에게 전달되는 컨텍스트가 비효율적이라고 판단될 경우, RAG 도입, 섹션별 요약 기능 추가 등 고급 컨텍스트 관리 기법 적용을 검토하고 필요시 구현합니다.
*   **검증 테스트:**
    *   매우 긴 아이디어나 복잡한 논의가 포함된 시나리오에서 토큰 사용량, 응답 속도, LLM 응답 품질을 측정하고, 컨텍스트 관리 전략이 효과적으로 작동하는지 확인합니다.

**단계 4.4: 성능 모니터링 및 최적화**
*   **지침:**
    1.  LLM 호출 횟수, 평균 토큰 사용량, 각 라운드별/페르소나별 처리 시간 등을 측정할 수 있는 간단한 로깅 또는 모니터링 기능을 추가합니다.
    2.  병목 지점을 식별하고 최적화 방안을 모색합니다. (예: 특정 LLM 호출이 너무 느리거나 비용이 많이 드는 경우, 프롬프트 수정 또는 모델 변경 고려)
*   **검증 테스트:**
    *   여러 번의 워크숍 실행을 통해 평균적인 성능 지표를 수집하고, 목표 수준에 도달하는지 확인합니다.

---

이 상세 구현 계획은 각 단계를 작고 관리 가능한 단위로 나누어, AI 개발자(Claude 등)와 협력하여 체계적으로 리팩토링 및 아키텍처 업데이트를 진행하는 데 도움이 될 것입니다. 각 단계 완료 후에는 반드시 검증 테스트를 통해 안정성을 확보하고 다음 단계로 나아가는 것이 중요합니다.