# AIdea Lab 리팩토링 및 아키텍처 업데이트: 상세 구현 계획

**최상위 목표:** 기존 AIdea Lab의 코드베이스를 안정적으로 리팩토링하고, "'통합 아이디어 문서' 중심의 반복적 개선 워크플로우" 아키텍처를 성공적으로 도입하여, 사용자가 아이디어를 제시하면 페르소나들이 효과적으로 협업하여 최선의 아이디어를 도출하는 시스템 구축.

**아키텍처 전환 전략:**
- **현재 상태**: `architecture.md`는 기존(구) 로직에 대한 내용으로, 순차적 페르소나 실행 방식
- **최종 목표**: 완전히 새로운 워크숍 매니저 중심 구조로 전환
- **전환 방식**: 현재 구조는 리팩토링을 통해 정리하되, 점진적으로 새 구조의 구성 요소를 도입하여 최종적으로 대체

**구현 우선순위 및 기능 유지 전략:**
- **Phase 1 (리팩토링)**: 기존 기능을 완벽하게 유지하면서 내부 구조만 개선
- **Phase 3 (새 아키텍처 도입)**: 새 구조로 완전 전환 후, 기존 기능 중 핵심적인 아이디어 발전 기능을 새 구조 위에서 재구현
- **우선순위**: 모든 부가 기능의 즉각적인 재구현보다는 핵심 기능의 안정적인 전환에 집중

**사전 준비:**
*   Git 브랜치 생성 (예: `refactor/phase1-ui-separation`)
*   기존 코드베이스 전체 백업
*   개발 환경 일치 확인 (`requirements.txt`)

---

**Phase 1: UI 및 상태 관리 집중 리팩토링 (`src/ui/app.py` 분해)**

**목표:** `app.py`의 복잡성을 낮추고, UI, 상태 관리, ADK 호출 로직을 분리하여 모듈성을 높인다. 현재 기능은 완벽하게 유지하면서 구조를 개선한다.

**단계 1.1: `AppStateManager` 클래스 분리 및 강화**
*   **지침:**
    1.  `src/ui/` 디렉토리 내에 `state_manager.py` 파일을 생성합니다.
    2.  `src/ui/app.py`에 정의된 `AppStateManager` 클래스 전체를 `src/ui/state_manager.py`로 이동시킵니다.
    3.  `src/ui/app.py`에서 `from .state_manager import AppStateManager`를 통해 임포트하도록 수정합니다.
    4.  `src/ui/app.py` 파일 하단에 정의된 전역 함수들 (`initialize_session_state`, `restart_session`, `add_message`, `process_text_for_display`, `show_system_message`)을 `AppStateManager` 클래스의 정적 메서드(static methods) 또는 인스턴스 메서드로 통합합니다.
    5.  `src/ui/app.py` 내에서 이 전역 함수들을 호출하던 모든 부분을 `AppStateManager.메서드명()` 형태로 변경합니다.
*   **검증 테스트:**
    *   애플리케이션을 실행했을 때, 기존과 동일하게 환영 메시지가 표시되고, 아이디어 입력 UI가 정상적으로 나타나는지 확인합니다.
    *   간단한 아이디어를 입력하고 1단계 분석을 실행했을 때, 기존과 동일하게 각 페르소나의 응답이 채팅 UI에 순차적으로 표시되는지 확인합니다. (기능 변경 없음 확인)
    *   "새 아이디어 분석" 버튼 등이 정상적으로 작동하여 세션 상태가 초기화되는지 확인합니다.
    *   **검증 기준**: 주요 기능(1단계 분석 결과 생성, 2단계 토론 진행)의 최종 출력물 내용이 리팩토링 전과 의미상 동등하거나 사용자가 차이를 느끼지 못하는 수준. UI의 외형적 변화는 허용.

**단계 1.2: `AppStateManager`를 통한 `st.session_state` 접근 일원화**
*   **지침:**
    1.  `src/ui/app.py` (및 리팩토링 과정에서 생성될 다른 UI 관련 파일들)에서 `st.session_state[...]` 또는 `st.session_state.get(...)`을 사용하여 직접 Streamlit 세션 상태에 접근하는 모든 코드를 찾습니다.
    2.  이러한 직접 접근 코드들을 `AppStateManager.get_state('키', 기본값)` 또는 `AppStateManager.set_state('키', 값)` 메서드 호출로 모두 변경합니다.
    3.  `AppStateManager` 내부에 `get_state`와 `set_state` 메서드가 없다면 이를 구현합니다. (이미 `AppStateManager`에 해당 기능이 있다면 이 단계는 검토 및 확인으로 대체)
*   **검증 테스트:**
    *   단계 1.1의 검증 테스트를 다시 수행하여 모든 기능이 여전히 정상적으로 작동하는지 확인합니다. (직접 접근을 메서드 호출로 변경해도 기능상 변화 없음 확인)
    *   특히 모델 변경, 아이디어 입력, 추가 정보 입력/저장 등 `st.session_state`를 많이 사용하는 기능들이 문제없이 작동하는지 집중적으로 테스트합니다.

**단계 1.3: ADK 연동 로직 캡슐화 (`adk_controller.py` 생성)**
*   **지침:**
    1.  `src/ui/` 디렉토리 내에 `adk_controller.py` 파일을 생성합니다.
    2.  `AdkController` 클래스를 정의합니다. 이 클래스는 생성자에서 `SessionManager` 인스턴스를 인자로 받도록 합니다.
    3.  `src/ui/app.py`의 `_run_phase1_analysis` 함수와 `_run_phase2_discussion` 함수 (및 이 함수들이 호출하는 하위 비동기 함수들) 내에서 ADK `Runner`를 생성하고, 에이전트를 실행하며, 이벤트 스트림을 처리하는 핵심 로직을 `AdkController` 클래스의 메서드(예: `async execute_phase1_workflow(...)`, `async execute_phase2_facilitator(...)`, `async execute_phase2_persona(...)`)로 이동시킵니다.
    4.  이 메서드들은 필요한 파라미터(예: `session_id`, `input_content`, 실행할 `agent` 객체)를 받고, 실행 결과(예: 처리된 응답 리스트, 다음 상태 정보)를 반환하도록 설계합니다.
    5.  `src/ui/app.py`에서는 `st.session_state`에 저장된 `SessionManager` 인스턴스를 사용하여 `AdkController` 인스턴스를 생성하고, 이 컨트롤러의 메서드를 호출하여 ADK 에이전트를 실행하도록 수정합니다. `app.py`는 ADK 실행의 세부 사항을 직접 알 필요가 없어집니다.
    6.  **오류 처리 강화**: ADK 관련 오류(API 키 문제, 네트워크 오류 등) 발생 시 `AdkController`에서 적절한 예외 처리 및 사용자 피드백 로직을 구현합니다.
*   **검증 테스트:**
    *   1단계 분석 전체 워크플로우와 2단계 토론(가능하다면 간단한 시나리오)이 기존과 동일하게 UI에 표시되고, `session.state`에 결과가 올바르게 저장되는지 확인합니다.
    *   ADK 관련 로직이 `AdkController`로 옮겨간 후에도 기능상 변화가 없는지 확인합니다.
    *   오류 발생 시(예: API 키 문제) 기존과 유사한 방식으로 사용자에게 피드백이 전달되는지 확인합니다.

**단계 1.4: UI 렌더링 로직 분리 (`views.py` 또는 `ui_renderer.py` 생성)**
*   **지침:**
    1.  `src/ui/` 디렉토리 내에 `views.py` (또는 `ui_renderer.py`) 파일을 생성합니다.
    2.  `src/ui/app.py`의 `main()` 함수 내에서 `st.session_state.analysis_phase` 값에 따라 분기되어 각기 다른 UI 요소(버튼, 입력 필드, 텍스트, 스피너 등)를 렌더링하는 코드 블록들을 식별합니다.
    3.  이러한 각 UI 상태별 렌더링 로직을 `views.py` 내의 별도 함수(예: `render_idle_view(state_manager)`, `render_phase1_pending_view(state_manager)`, `render_phase1_complete_view(state_manager, adk_controller)`, `render_user_input_view(state_manager, prompt_message)`)로 분리합니다. 각 뷰 함수는 필요한 상태 정보나 컨트롤러 객체를 인자로 받을 수 있습니다.
    4.  `src/ui/app.py`의 `main()` 함수는 매우 간결해져야 하며, 주로 `AppStateManager`를 통해 현재 상태를 가져오고, 해당 상태에 맞는 뷰 함수를 `views.py`에서 호출하는 역할만 수행하도록 합니다.
    5.  **UI 변경 전략**: Phase 1에서는 기존 채팅 UI를 유지하면서 내부 로직만 모듈화. "통합 아이디어 문서" 시각화 UI는 Phase 3에서 새로운 워크플로우가 도입될 때 함께 점진적으로 개발 및 적용.
*   **검증 테스트:**
    *   애플리케이션의 모든 화면 전환(아이디어 입력 전, 분석 중, 1단계 완료, 2단계 사용자 입력 대기, 2단계 완료 등)이 기존과 동일하게 부드럽게 이루어지는지 확인합니다.
    *   각 화면에 표시되는 버튼, 텍스트, 입력 필드 등이 정확히 렌더링되는지 확인합니다.
    *   UI 요소와 연결된 콜백 함수들이 `AppStateManager` 또는 `AdkController`의 적절한 메서드를 호출하여 기능이 정상 작동하는지 확인합니다.

**단계 1.5: (선택적) 공통 UI 컴포넌트 분리 (`components.py` 생성)**
*   **지침:**
    1.  `src/ui/` 디렉토리 내에 `components.py` 파일을 생성합니다.
    2.  여러 뷰에서 반복적으로 사용되는 UI 구성 로직(예: 채팅 메시지 리스트 렌더링, 특정 형태의 버튼 그룹 등)이 있다면, 이를 `components.py` 내의 재사용 가능한 함수로 만듭니다.
    3.  `views.py` 등에서 이 공통 컴포넌트 함수를 호출하여 사용합니다.
*   **검증 테스트:**
    *   공통 컴포넌트를 사용하는 모든 UI 부분이 기존과 동일하게 표시되고 작동하는지 확인합니다.

---

**Phase 2: 새로운 아키텍처 도입 준비**

**목표:** "'통합 아이디어 문서' 중심 워크플로우"를 도입하기 위한 데이터 구조 및 핵심 컨트롤러의 기본 틀을 마련한다.

**단계 2.1: "통합 아이디어 문서" 데이터 구조 정의**
*   **지침:**
    1.  `src/core/` 디렉토리(신규 생성) 내에 `idea_document_schema.py` (또는 유사한 이름) 파일을 생성합니다.
    2.  "통합 아이디어 문서"의 초기 JSON 스키마 또는 Python Pydantic 모델을 정의합니다. (예: `document_id`, `title`, `initial_prompt`, `user_info`, `sections` (딕셔너리), `version`, `workshop_log` 등).
    3.  `sections` 내부에는 아이디어의 각 측면(예: `problem_definition`, `target_audience`, `core_features`, `revenue_model`, `comments`)을 위한 구조를 정의합니다.
    4.  **섹션별 구조**: 각 섹션은 `content` (주요 내용), `last_updated_by` (최종 수정자), `comments` (페르소나별 의견 리스트), `history` (간단한 변경 로그) 등의 하위 필드를 포함할 수 있습니다.
*   **검증 테스트:**
    *   정의된 스키마/모델이 예상하는 데이터를 올바르게 표현할 수 있는지 간단한 인스턴스를 만들어 확인합니다.
    *   Pydantic 모델을 사용했다면, 유효성 검사 기능이 정상 작동하는지 확인합니다.

**단계 2.2: `SessionManager` 또는 `AppStateManager`에 "통합 아이디어 문서" 관리 기능 추가**
*   **지침:**
    1.  `src/ui/state_manager.py` (또는 `src/session_manager.py`의 ADK 세션 상태 관련 부분)에 "통합 아이디어 문서"를 `session.state` (또는 `st.session_state`)에 초기화하는 함수를 추가합니다. (예: `initialize_idea_document(session_id, initial_idea_data)`).
    2.  "통합 아이디어 문서" 내의 특정 경로(예: `idea_document.sections.revenue_model.content`)에 값을 안전하게 읽고 쓰는 유틸리티 함수를 추가합니다. (딕셔너리 경로 접근 헬퍼)
    3.  **ADK output_key 제약사항 대응**: ADK의 output_key가 최상위 키만 지원한다고 가정하고, UI 컨트롤러가 output_key로 반환된 결과를 받아 "통합 아이디어 문서"의 적절한 중첩된 경로에 업데이트하는 로직을 포함합니다.
*   **검증 테스트:**
    *   초기화 함수 호출 시 `session.state` (또는 `st.session_state`)에 정의된 스키마대로 "통합 아이디어 문서"가 생성되는지 확인합니다.
    *   읽기/쓰기 유틸리티 함수가 중첩된 경로에 대해 정확하게 작동하는지 단위 테스트를 작성하거나 수동으로 검증합니다.

**단계 2.3: "워크숍 매니저 에이전트" 기본 틀 생성**
*   **지침:**
    1.  `src/agents/` 디렉토리 내에 `workshop_manager_agent.py` 파일을 생성합니다.
    2.  ADK `LlmAgent`를 상속받는 `WorkshopManagerAgent` 클래스의 기본 구조를 작성합니다.
    3.  `InstructionProvider`를 사용하여 간단한 초기 프롬프트를 정의합니다. (예: "당신은 아이디어 워크숍 매니저입니다. 현재 아이디어 문서를 분석하고 다음 단계를 지시하세요.")
    4.  워크숍 매니저가 출력할 JSON 지시사항의 기본 스키마를 명시합니다:
        ```json
        {
          "next_round_goal": "다음 라운드의 목표 설명",
          "assignments": [
            {
              "persona_id": "marketer|critic|engineer",
              "task_instruction": "구체적인 작업 지시사항",
              "input_document_paths": ["idea_document.sections.revenue_model.content", ...]
            }
          ],
          "request_to_user": null, // 또는 사용자에게 질문할 내용
          "workshop_status": "in_progress|ready_for_final_review|completed"
        }
        ```
    5.  `output_key`를 설정합니다. (예: `"workshop_manager_decision"`)
    6.  **JSON 파싱 및 다음 액션 결정**: UI 컨트롤러(app.py 또는 분리된 workshop_flow_manager.py)에서 JSON 파싱 및 다음 액션 결정 로직을 담당하도록 설계합니다. 이는 ADK 에이전트의 역할을 순수한 LLM 기반 판단 및 출력 생성에 집중시키기 위함입니다.
*   **검증 테스트:**
    *   `WorkshopManagerAgent` 인스턴스가 정상적으로 생성되는지 확인합니다.
    *   (아직 실행 로직은 없으므로) 프롬프트가 기본적으로 구성되는지 간단히 확인할 수 있습니다.

---

**Phase 3: "통합 아이디어 문서" 중심 워크플로우 구현**

**목표:** 기존 1, 2단계 로직을 "'통합 아이디어 문서' 중심의 반복적 개선 워크플로우"로 대체한다.

**단계 3.1: 워크숍 매니저 에이전트의 핵심 로직 및 프롬프트 상세 구현**
*   **지침:**
    1.  `WorkshopManagerAgent`의 `InstructionProvider`를 고도화합니다. "통합 아이디어 문서"(`state.idea_document`) 내용을 입력받아 분석하고, 다음 라운드 목표, 참여할 페르소나, 각 페르소나에게 전달할 구체적인 작업 지시(참조할 문서 섹션 경로 포함)를 JSON 형식으로 생성하도록 LLM 프롬프트를 상세하게 설계합니다.
    2.  의견 충돌 시 중재 방안, 사용자 개입 요청 조건 등을 프롬프트에 포함합니다.
    3.  **사용자 개입 시점**: 명확한 선택지가 있고 페르소나 간 합의가 어렵거나, 아이디어의 방향성을 결정할 중요한 분기점이라고 판단될 때 구체적인 질문(예: "A안과 B안 중 어떤 것을 선호하십니까?")을 요청하도록 프롬프트에 포함합니다.
    4.  **라운드 종료 조건**: 워크숍 매니저 LLM의 종합적인 판단(예: "아이디어의 주요 섹션이 충분히 구체화되었고, 더 이상 중요한 미결정 사항이 없음")을 기본으로 하되, 최대 라운드 수 제한도 고려하도록 설계합니다.
    5.  **폴백 메커니즘**: 잘못된 JSON 생성이나 예상 못한 지시 시의 기본 폴백 동작을 정의합니다.
*   **검증 테스트:**
    *   다양한 "통합 아이디어 문서" 상태(초기, 중간, 거의 완성)를 시뮬레이션하여 `WorkshopManagerAgent`를 (격리된 환경에서 `AdkController`를 통해) 실행했을 때, 의도한 대로 다음 라운드 목표와 작업 할당 JSON이 생성되는지 확인합니다.
    *   생성된 JSON이 미리 정의한 스키마를 준수하는지 확인합니다.
    *   JSON 파싱 오류나 예상 못한 출력에 대한 폴백 동작이 정상 작동하는지 확인합니다.

**단계 3.2: 페르소나 에이전트 수정 (새로운 워크플로우에 맞게)**
*   **지침:**
    1.  기존 페르소나 에이전트들(`MarketerPersonaAgent`, `CriticPersonaAgent`, `EngineerPersonaAgent`)의 `InstructionProvider`를 수정합니다.
    2.  프롬프트는 워크숍 매니저로부터 `session.state`를 통해 전달받은 작업 지시(`state.current_task_instruction_for_XYZ`)와 "통합 아이디어 문서"의 지정된 섹션 내용(`state.idea_document.sections.some_section...`)을 컨텍스트로 받도록 합니다.
    3.  페르소나의 LLM 출력은 "통합 아이디어 문서"의 특정 부분에 대한 수정 제안, 새로운 내용 추가, 또는 코멘트 형식의 텍스트가 되도록 유도합니다.
    4.  각 페르소나 에이전트의 `output_key` (예: `"marketer_contribution"`)를 통해 이 텍스트 결과가 반환되도록 합니다.
    5.  **컨텍스트 관리 전략**: 초기에는 규칙 기반(작업 지시 시 명시적으로 관련 문서 섹션 경로 지정)과 LLM의 요약/판단 능력 조합으로 구현합니다. 토큰 사용량은 각 호출 시 전달되는 문서 섹션의 크기를 제한하고, 전체 문서 대신 요약본이나 변경 사항 위주로 전달하여 제어합니다.
*   **검증 테스트:**
    *   워크숍 매니저가 생성한 작업 지시와 문서 일부를 컨텍스트로 주었을 때, 각 페르소나가 해당 작업에 맞는 분석 결과/제안을 텍스트로 생성하는지 확인합니다.

**단계 3.3: UI 컨트롤러의 메인 워크플로우 로직 변경**
*   **지침:**
    1.  `src/ui/app.py` (또는 분리된 `workshop_flow_manager.py`)의 메인 로직을 수정하여, 기존 1, 2단계 실행 로직을 새로운 라운드 기반 워크플로우로 대체합니다.
    2.  **새로운 워크플로우**:
        a.  워크숍 매니저 에이전트 실행 (`AdkController` 사용).
        b.  반환된 JSON(`state.workshop_manager_decision`) 파싱.
        c.  **오류 처리**: 잘못된 JSON이나 예상 못한 지시 시, 정의된 기본 폴백 동작(사용자에게 오류 알림 후 이전 단계로 돌아가기, 워크숍 매니저에게 재시도 요청) 수행. 심각한 오류 시 워크숍을 안전하게 중단하고 로그 기록.
        d.  JSON 지시에 따라 각 페르소나에게 작업 할당:
            i.  `session.state`에 페르소나별 작업 지시 및 컨텍스트 경로 저장.
            ii. 해당 페르소나 에이전트 실행 (`AdkController` 사용).
            iii. **문서 업데이트 메커니즘**: 페르소나의 결과(`state.persona_X_contribution`)를 가져와 워크숍 매니저가 작업 지시 시 명시한 "통합 아이디어 문서"의 특정 섹션/경로에 UI 컨트롤러가 병합/업데이트합니다. (예: 코멘트 추가, 특정 필드 내용 교체)
        e.  **충돌 해결**: 순차적 작업 할당을 기본으로 하여 동시에 여러 페르소나가 동일 섹션을 수정하지 않도록 합니다. 병렬 작업이 필요한 경우, 각 페르소나는 별도의 "제안" 영역에 의견을 작성하고, 이후 워크숍 매니저나 사용자가 검토하여 병합/선택합니다.
        f.  모든 페르소나 작업 완료 후 다시 (a)로 돌아가 워크숍 매니저 실행 (라운드 반복).
        g.  **사용자 개입 처리**: 워크숍 매니저가 사용자 개입을 요청하면, UI에 해당 질문을 표시하고 사용자 입력을 받아 `session.state`에 저장 후 워크숍 매니저에게 전달. 사용자가 응답하지 않거나 부적절한 응답 시, 미리 정의된 기본 선택지를 따르거나 해당 이슈를 "미결정 사항"으로 문서에 기록하고 다른 주제로 전환.
        h.  워크숍 매니저가 종료를 결정하면 워크숍 종료.
*   **검증 테스트:**
    *   사용자가 아이디어를 입력하면, 워크숍 매니저가 첫 라운드를 지시하고, 지정된 페르소나가 작업을 수행하며, 그 결과가 "통합 아이디어 문서"에 반영되는 전체 흐름을 테스트합니다.
    *   몇 차례 라운드가 반복되면서 "통합 아이디어 문서"가 점진적으로 발전하는지 확인합니다.
    *   사용자 개입 요청 및 응답 처리가 정상적으로 이루어지는지 확인합니다.
    *   오류 상황에서 시스템이 우아하게 대처하는지 확인합니다.

**단계 3.4: "통합 아이디어 문서" 시각화 UI 개선**
*   **지침:**
    1.  `src/ui/views.py` (또는 관련 UI 모듈)에서 "통합 아이디어 문서"(`state.idea_document`)의 내용을 사용자에게 효과적으로 보여주는 UI를 구현/개선합니다.
    2.  문서의 구조(섹션, 하위 섹션), 내용, 코멘트, 변경 이력(간단한 형태) 등을 명확하게 시각화합니다.
    3.  사용자가 문서를 쉽게 탐색하고 이해할 수 있도록 합니다.
    4.  **UI 통합 전략**: 초기에는 문서의 주요 내용만 텍스트 형태로 보여주다가, 점차 인터랙티브한 문서 뷰로 발전시킵니다. 기존 채팅 UI는 워크숍 매니저 및 페르소나의 발언을 표시하는 로그/대화창 형태로 유지하거나, 문서 뷰와 통합할 수 있습니다.
*   **검증 테스트:**
    *   워크숍이 진행됨에 따라 "통합 아이디어 문서"가 업데이트될 때마다 UI에도 해당 변경 사항이 정확하고 보기 좋게 반영되는지 확인합니다.
    *   사용자가 문서의 다양한 섹션을 쉽게 탐색할 수 있는지 확인합니다.

---

**Phase 4: 테스트, 최적화 및 안정화**

**목표:** 새로운 아키텍처가 안정적으로 작동하고, 성능 및 사용자 경험을 개선한다.

**단계 4.1: 통합 시나리오 테스트 및 예외 처리 강화**
*   **지침:**
    1.  다양한 종류의 아이디어, 사용자 입력, 페르소나 상호작용 시나리오를 가정하여 엔드투엔드 테스트를 수행합니다.
    2.  LLM 응답이 예상과 다르거나(예: JSON 형식 오류), 특정 페르소나 작업이 실패하는 등 예외 상황에 대한 오류 처리 로직을 강화하고, 사용자에게 적절한 피드백을 제공하도록 합니다.
    3.  **의도적 오류 테스트**: 잘못된 입력을 주거나 예외 상황을 유도하여 시스템이 우아하게 대처하는지 확인합니다.
*   **검증 테스트:**
    *   장시간 사용 또는 복잡한 상호작용에도 시스템이 안정적으로 유지되는지 테스트합니다.
    *   모든 폴백 메커니즘이 정상 작동하는지 확인합니다.

**단계 4.2: 프롬프트 튜닝 및 LLM 응답 품질 지속 개선**
*   **지침:**
    1.  워크숍 매니저 및 각 페르소나 에이전트의 프롬프트를 실제 사용 사례를 통해 얻은 피드백을 바탕으로 지속적으로 수정하고 개선하여, LLM 응답의 정확성, 일관성, 유용성을 높입니다.
    2.  **컨텍스트 관리 최적화**: LLM에게 "현재 작업에 가장 관련 있는 문서 섹션은 무엇이며, 그 핵심 내용은 무엇인가?"를 판단하게 하고, 그 판단을 바탕으로 페르소나에게 전달할 컨텍스트를 구성합니다. 프롬프트 튜닝으로 정확도를 개선합니다.
*   **검증 테스트:**
    *   여러 아이디어에 대해 워크숍을 진행시켜보고, 생성되는 "통합 아이디어 문서"의 품질과 페르소나들의 기여도를 평가합니다.
    *   사용자(또는 내부 테스터)로부터 결과물에 대한 만족도 피드백을 받습니다.
    *   **새로운 아키텍처 성공 기준**: 1) 아이디어 결과물의 질 향상 (내부 평가 또는 사용자 평가), 2) 컨텍스트 관리 효율성 증대 (평균 토큰 사용량 감소 또는 처리 속도 향상), 3) 새로운 페르소나/기능 추가 시 개발 용이성 향상 등을 측정합니다.

**단계 4.3: 컨텍스트 관리 전략 최적화**
*   **지침:**
    1.  "통합 아이디어 문서"가 매우 커지거나, 특정 페르소나에게 전달되는 컨텍스트가 비효율적이라고 판단될 경우, RAG 도입, 섹션별 요약 기능 추가 등 고급 컨텍스트 관리 기법 적용을 검토하고 필요시 구현합니다.
    2.  **토큰 사용량 제어**: 매우 긴 아이디어나 복잡한 논의에서도 효율적인 컨텍스트 관리가 이루어지도록 최적화합니다.
*   **검증 테스트:**
    *   매우 긴 아이디어나 복잡한 논의가 포함된 시나리오에서 토큰 사용량, 응답 속도, LLM 응답 품질을 측정하고, 컨텍스트 관리 전략이 효과적으로 작동하는지 확인합니다.

**단계 4.4: 성능 모니터링 및 최적화**
*   **지침:**
    1.  LLM 호출 횟수, 평균 토큰 사용량, 각 라운드별/페르소나별 처리 시간 등을 측정할 수 있는 간단한 로깅 또는 모니터링 기능을 추가합니다.
    2.  병목 지점을 식별하고 최적화 방안을 모색합니다. (예: 특정 LLM 호출이 너무 느리거나 비용이 많이 드는 경우, 프롬프트 수정 또는 모델 변경 고려)
*   **검증 테스트:**
    *   여러 번의 워크숍 실행을 통해 평균적인 성능 지표를 수집하고, 목표 수준에 도달하는지 확인합니다.
    *   성능 개선 사항이 사용자 경험에 실질적인 영향을 미치는지 평가합니다.

---

**전체 구현 계획 요약**

이 상세 구현 계획은 다음과 같은 핵심 전략을 따릅니다:

1. **점진적 전환**: 기존 기능을 완벽히 유지하면서 내부 구조를 개선한 후, 새로운 아키텍처로 전환
2. **명확한 책임 분리**: UI 컨트롤러가 워크플로우 조율, 워크숍 매니저가 LLM 기반 판단, 페르소나가 전문적 분석 담당
3. **견고한 오류 처리**: 각 단계에서 예상 가능한 오류에 대한 폴백 메커니즘 구비
4. **성능 최적화**: 컨텍스트 관리와 토큰 사용량 최적화를 통한 효율성 향상
5. **사용자 중심 설계**: 사용자 개입 시점 명확화 및 직관적인 문서 시각화

각 단계 완료 후에는 반드시 검증 테스트를 통해 안정성을 확보하고 다음 단계로 나아가는 것이 중요합니다.