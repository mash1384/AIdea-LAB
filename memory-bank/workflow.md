# AIdea Lab: 아키텍처 기반 상세 구현 워크플로우 (상세내용이 필요할 경우 /prd.md 참고)

## Phase 0: 준비 및 환경 설정 (필수 선행)

* **목표**: 개발 환경을 완벽히 구축하고, Google ADK와 선택된 Gemini LLM API의 기본 연동 및 작동을 확실하게 검증합니다.
* **구현 및 참고 아키텍처 항목 상세**:
    1.  **기술 스택 (1인 개발자 추천 - MVP, Google ADK 중심) (원본 7.)**:
        * **선정 및 확인**: Python, Google ADK, UI 도구(Streamlit/Gradio 중 MVP용 최종 결정), LLM(아래 항목에서 확정될 Gemini 모델)을 주요 기술로 확정하고, 각 기술의 호환성 및 기본 사용법을 숙지합니다. MVP 단계에서는 SQLite 사용을 염두에 둡니다.
    2.  **LLM 모델 및 API 최종 확인 (필수 선행 작업) (원본 9.1.)**:
        * **최종 확정**: 사용한 Gemini 모델의 **정확한 명칭, 버전, API 엔드포인트, 인증 방식(API 키/서비스 계정), 호출 제한(Quotas) 및 토큰당 비용 정책**을 Google 공식 문서를 통해 **반드시 최종 확인하고 문서화**합니다. 이는 전체 프로젝트 비용 및 성능에 직접적인 영향을 미칩니다.
    3.  **Google ADK 설치 및 개발 환경 구축 절차 확정 (필수 선행 작업) (원본 10.1.)**:
        * **환경 구축 완료**: 공식 가이드라인에 따라 **Google ADK를 설치**하고, Python **가상 환경을 구성**합니다. 필요시 Google Cloud SDK(gcloud CLI)를 설치하고 개발 환경 인증을 완료합니다. Gemini API 사용을 위한 **API 키 또는 서비스 계정 키를 `.env` 파일 등을 통해 안전하게 설정**하고 ADK가 이를 참조할 수 있도록 합니다.
        * **기본 작동 검증**: ADK 공식 문서에서 제공하는 **가장 간단한 `LlmAgent` 또는 워크플로우 예제를 (LLM 연동 포함하여) 실제로 실행**하여, 개발 환경이 올바르게 설정되었고 ADK와 LLM 간의 기본 통신이 원활함을 확인합니다.

## Phase 1: 단일 페르소나 아이디어 분석 (핵심 기능의 최소 단위 구현)

* **목표**: 사용자가 아이디어를 입력하면, 미리 정의된 단일 AI 페르소나가 해당 아이디어를 분석하고, 그 결과를 UI를 통해 사용자에게 보여주는 가장 기본적인 End-to-End 흐름을 완성합니다. 이를 통해 ADK 에이전트의 기본 구조, 프롬프트 적용, LLM 연동, `session.state` 활용, UI 연동의 핵심 사이클을 검증합니다.
* **구현 및 참고 아키텍처 항목 상세**:
    1.  **프로젝트 목표 (원본 1.)**: "사용자가 아이디어를 입력하면, 다양한 AI 페르소나 에이전트들이 각자의 관점에서 아이디어를 분석..." 목표의 가장 작은 단위(단일 페르소나 분석)를 실현합니다.
    2.  **핵심 철학 (원본 2.)**:
        * `Google ADK - 통합 에이전트 개발 및 오케스트레이션`: 첫 **ADK `LlmAgent`를 설계하고 개발**합니다. ADK가 제공하는 에이전트 생명주기, 프롬프트 관리, 상태 관리 등의 기본 기능을 활용합니다.
        * `MCP (Model-Context Protocol) - 외부 정보/도구 연동 표준화 (ADK Tool 메커니즘 활용)`: LLM API 호출을 ADK `LlmAgent`의 내장 LLM 연동 기능을 통해 수행함으로써, 외부 서비스(LLM) 접근을 ADK 프레임워크 내에서 일관된 방식으로 처리하는 MCP 철학의 초기 단계를 경험합니다.
    3.  **AI 페르소나 정의 (MVP: 3가지 핵심 페르소나) (원본 4.)**:
        * **선택 및 구체화**: MVP 페르소나 중 1개(예: 비판적 분석가 (원본 4.1.))를 선택합니다. 해당 페르소나의 **상세 역할, 목표, 말투/스타일, 전문 분야** 정의를 바탕으로 **LLM에게 전달할 구체적인 시스템 프롬프트**를 작성합니다.
    4.  **LLM 서비스 활용 관련 상세 전략 (MVP 추천) (원본 9.)**:
        * `LLM 서비스 도구(Tool) 인터페이스 정의 (MCP 개념 적용) (원본 9.2.)`: 이 단계에서는 `LlmAgent`의 `model` 파라미터를 통해 Gemini 모델을 직접 사용하는 것을 우선으로 합니다. 별도의 `GeminiLLMTool` 클래스 구현은 다음 단계에서 오케스트레이터의 LLM 활용 시 고려합니다.
        * `API 호출 시 파라미터 최종 값 결정 (원본 9.3.)`: 작성된 시스템 프롬프트와 함께, 선택된 페르소나의 특성을 반영하는 `temperature` (예: 비판가는 0.2~0.4로 낮게 설정하여 일관성 있는 답변 유도), `maxOutputTokens` 등의 **LLM API 파라미터 초기값을 설정하고 테스트**합니다.
        * `프롬프트 엔지니어링 및 관리 (원본 9.5.)`: 작성된 시스템 프롬프트와 사용자의 아이디어 입력을 결합하여 첫 번째 페르소나용 프롬프트를 구성하고, 실제 응답을 보며 프롬프트 개선의 필요성을 인지합니다.
    5.  **Google ADK 활용 관련 상세 전략 (MVP 추천) (원본 10.)**:
        * `ADK 내부 에이전트 간 데이터 구조 및 session.state 활용 정의 (원본 10.2.)`: `session.state`에 사용자의 아이디어를 저장할 키(예: `initial_idea`)와, 실행된 페르소나 에이전트의 응답을 저장할 `output_key`(예: `critic_response`)를 명확히 정의합니다.
        * `상태 관리(메모리) 메커니즘 구체적 사용법 (ADK session.state 활용) (원본 10.3.)`: `LlmAgent`의 `instruction` (또는 프롬프트 템플릿) 내에서 `{state.initial_idea}`와 같이 `session.state` 값을 동적으로 참조하고, 에이전트의 최종 응답 텍스트가 `session.state[output_key]`에 자동으로 저장되도록 `output_key`를 설정합니다.
    6.  **사용자 인터페이스 (UI) 설계 (MVP 추천: Streamlit 또는 Gradio 활용) (원본 11.)**:
        * `UI 목표 (원본 11.1.)`: "핵심 기능을 쉽고 직관적으로 사용"할 수 있도록 가장 기본적인 UI를 제공합니다.
        * `주요 화면 구성 및 기능 (원본 11.2.)`: **시작 화면 (원본 11.2.1.)** (아이디어 입력 텍스트 영역, "분석 요청" 버튼)과 **워크숍 진행 화면 (원본 11.2.2.)** (단일 페르소나의 아이콘/이름과 해당 페르소나가 생성한 의견 텍스트 표시)을 구현합니다.
        * `사용자 경험(UX) 흐름 (원본 11.3.)`: [시작] -> [아이디어 입력 및 제출] -> [단일 페르소나 의견 로딩 후 표시]의 기본 흐름을 구현합니다.
        * `UI 구현 도구 (원본 11.4.)`: Streamlit 또는 Gradio 중 최종 선택한 도구를 사용하여 위 화면들을 실제 코드로 구현합니다.
    7.  **시스템 아키텍처 (원본 3.)**: (단순화된 초기 형태)
        * `시스템 개요도 (High-Level Architecture - Google ADK 기반) (원본 3.1.)`: [User Interface] <-> [Single Persona ADK Agent (예: P_Critic_ADK)] <-> [LLM Service Tool (LlmAgent의 LLM 호출 기능)]의 단방향 흐름을 구현합니다.
        * `주요 구성 요소 상세 (기술 스택 중심 요약 - Google ADK 기반) (원본 3.4.)`: UI (Streamlit/Gradio), 선택된 단일 페르소나 에이전트 (ADK `LlmAgent`), LLM 서비스 (Gemini API)의 세 가지 핵심 요소로 구성됩니다.
    8.  **오케스트레이터 에이전트 로직 상세 설계 중 사용자 입력 처리 (원본 6.3.)**: 이 단계에서는 "초기 아이디어 입력" 부분만 구현됩니다.

## Phase 2: 멀티 페르소나 순차 실행 및 오케스트레이션 (워크플로우 구축)

* **목표**: 오케스트레이터 에이전트(ADK 워크플로우 에이전트)를 도입하여, 정의된 모든 MVP 페르소나가 사용자의 아이디어에 대해 순차적으로 의견을 제시하고, 각 페르소나가 이전 페르소나의 의견을 참고하여 분석을 진행하는 핵심 워크플로우를 완성합니다.
* **구현 및 참고 아키텍처 항목 상세**:
    1.  **AI 페르소나 정의 (MVP: 3가지 핵심 페르소나) (원본 4.)**:
        * **모든 페르소나 구현**: 창의적 마케터 (원본 4.2.), 현실적 엔지니어/개발자 (원본 4.3.) 각각에 대한 시스템 프롬프트를 완성하고, 각 페르소나를 고유한 `LlmAgent` (각자의 `output_key` 사용)로 구현합니다. (비판적 분석가는 Phase 1에서 구현)
    2.  **페르소나 간 상호작용 방식 (MVP: "Google ADK 워크플로우 기반 순차적 의견 교환 및 참조" + 확장성 고려) (원본 5.)**:
        * `핵심 아이디어 (원본 5.1.)`: **오케스트레이터 에이전트가 사회자/진행자 역할**을 하며, 정의된 순서대로 각 페르소나에게 발언을 요청합니다. 이때 오케스트레이터는 **이전 페르소나(들)의 발언 내용(또는 요약)을 현재 페르소나에게 전달**하여 참고하도록 합니다. MVP에서는 사용자의 직접적인 개입은 최소화합니다.
        * `구체적인 작동 방식 예시 (기본 라운드) (원본 5.2.)`: 사용자의 아이디어 입력 후, 오케스트레이터가 `창의적 마케터` -> `비판적 분석가` -> `현실적 엔지니어` 순서로 각 페르소나 ADK Agent를 ADK 내부 통신 메커니즘으로 호출하는 로직을 구현합니다.
    3.  **오케스트레이터 에이전트 로직 상세 설계 (MVP - Google ADK 활용) (원본 6.)**:
        * `핵심 역할 및 책임 (Google ADK 에이전트로서) (원본 6.1.)`: 오케스트레이터는 전체 워크숍 세션 관리, 페르소나 에이전트 호출 및 응답 처리, 대화 흐름 제어, 상태(메모리) 관리 등을 담당합니다.
        * `Google ADK 워크플로우 상세 설계 (MVP 추천: 순차 실행 워크플로우 에이전트) (원본 6.2.1.)`:
            * **워크플로우 에이전트 사용**: Google ADK가 제공하는 **순차 실행 워크플로우 에이전트 (`SequentialAgent` 또는 유사 기능)를 사용**하여 오케스트레이터를 구현합니다.
            * **워크플로우 단계 정의**: [시작] 아이디어 수신 및 세션 초기화 -> [1단계] 첫 페르소나(예: 마케터) 호출 (전달 메시지: 아이디어) -> [2단계] 두 번째 페르소나(예: 분석가) 호출 (전달 메시지: 아이디어 + 첫 페르소나 의견 요약/전체. 이때, **오케스트레이터의 LLM 도구 활용 상세 중 (선택적) 대화 히스토리 요약 시 (원본 6.2.3.)** 항목을 참고하여, 필요시 LLM 도구를 사용하여 이전 의견을 요약하는 기능 포함 고려) -> [3단계] 세 번째 페르소나(예: 엔지니어) 호출 (전달 메시지: 아이디어 + 이전 두 페르소나 의견 요약/전체).
            * **메시지 스키마**: **A2A 프로토콜 메시지 스키마 (초안 - 추후 확정 필요) (원본 6.2.1. 하위)** 에서 정의한 `session_id`, `task_type`, `idea_text`, `previous_dialogue_summary` 등의 필드를 포함하는 **ADK 내부 호출 시의 데이터 구조를 정의**하고 사용합니다. (MVP에서는 ADK 내부 통신이지만, 향후 A2A 호환성을 염두에 둔 구조 권장)
            * **상태 관리 (ADK 기능 활용) (원본 6.2.1. 하위)**: `dialogue_history`를 `session.state`에 턴 기반으로 누적하거나, 각 페르소나의 응답을 개별 키(`persona_responses` 딕셔너리 등)로 `session.state`에 체계적으로 저장하고 관리합니다.
    4.  **시스템 아키텍처 (원본 3.)**:
        * `시스템 개요도 (High-Level Architecture - Google ADK 기반) (원본 3.1.)`: `Orchestrator_ADK`가 중심이 되어 `AI Persona Agent Pool (P_Critic_ADK, P_Marketer_ADK, P_Engineer_ADK)` 내의 각 페르소나 에이전트와 `ADK Internal Call / Dataflow`를 통해 상호작용하는 전체 구조를 구현합니다.
        * `개요도 설명 (Google ADK 중심) (원본 3.2.)`: 오케스트레이터의 역할(워크플로우/라우터 기능), 페르소나 에이전트의 역할(특화된 ADK 에이전트), 에이전트 간 상호작용(ADK 내부 통신 및 오케스트레이션 메커니즘)을 실제 코드로 구현하며 이해도를 높입니다.
        * `주요 상호작용 흐름 (Google ADK 내부 메커니즘 기반) (원본 3.3.)`: 1. UI -> Orchestrator, 2. Orchestrator -> Persona (내부 호출), 3. Persona -> Orchestrator (응답 반환), 4. Orchestrator -> UI (응답 전달)의 흐름을 구체적으로 구현합니다.
    5.  **Google ADK 활용 관련 상세 전략 (MVP 추천) (원본 10.)**:
        * `ADK 내부 에이전트 간 데이터 구조 및 session.state 활용 정의 (원본 10.2.)`: `session.state`에 `initial_idea`, `dialogue_history` (각 턴별 발언자, 내용, 타임스탬프 포함), `current_round`, `persona_responses` (각 페르소나의 최종 응답) 등의 스키마를 구체적으로 정의하고 활용합니다.
        * `상태 관리(메모리) 메커니즘 구체적 사용법 (ADK session.state 활용) (원본 10.3.)`: 오케스트레이터가 `session.state`를 초기화하고, 하위 페르소나 에이전트 실행을 통해 업데이트되는 `session.state`를 관리합니다. 페르소나 에이전트들은 `instruction`을 통해 필요한 `session.state` 정보를 컨텍스트로 활용하고, 자신의 분석 결과를 `output_key`를 통해 `session.state`에 기록합니다.
    6.  **사용자 인터페이스 (UI) 설계 (MVP 추천: Streamlit 또는 Gradio 활용) (원본 11.)**:
        * `워크숍 진행 화면 (Workshop/Chat Screen) (원본 11.2.2.)`:
            * **대화창 영역**: 각 AI 페르소나의 아이콘/이름과 함께 해당 페르소나가 생성한 의견을 **순서대로 또는 누적하여 표시**합니다. 오케스트레이터의 안내 메시지(예: "창의적 마케터의 분석이 완료되었습니다. 이제 비판적 분석가가 검토합니다.")를 추가합니다.
            * **진행 상태 표시 영역**: 현재 어떤 페르소나가 분석 중인지 또는 전체 워크숍의 진행 단계를 간략히 표시합니다.
            * **UX 고려사항**: **진행 피드백 강화** (예: 각 페르소나 응답 생성 시 "AI [페르소나 이름]이(가) 답변을 생성 중입니다..." 와 함께 Streamlit/Gradio의 스피너 또는 진행 바 표시)를 통해 사용자의 기다림을 관리합니다.

## Phase 3: 최종 요약 및 워크숍 기본 완료 (사용자 가치 제공)

* **목표**: 모든 페르소나의 순차 분석이 완료된 후, 오케스트레이터가 LLM을 활용하여 전체 논의 내용을 종합한 최종 요약 보고서를 생성하고, 이를 사용자에게 "워크숍 종료 및 최종 요약 보기" 옵션을 통해 제공합니다.
* **구현 및 참고 아키텍처 항목 상세**:
    1.  **오케스트레이터 에이전트 로직 상세 설계 (MVP - Google ADK 활용) (원본 6.)**:
        * `Google ADK 워크플로우 상세 설계 (원본 6.2.1.)`: 워크플로우의 마지막 단계로 `[라운드 종료] "다음 단계 제안" 로직 실행` 부분을 구현합니다.
        * `"다음 단계 제안" 로직 상세화 (MVP 추천) (원본 6.2.2.)`:
            * **옵션 제시 조건**: MVP에서는 3명의 페르소나가 모두 1회씩 발언을 성공적으로 완료한 경우입니다.
            * **제시 옵션 중 `1. "워크숍 종료 및 최종 요약 보기"` 기능을 우선 구현**합니다.
                * **오케스트레이터 행동**: 현재까지 `session.state`에 누적된 `dialogue_history` 전체 또는 각 페르소나의 주요 응답(`persona_responses`)을 입력으로 하여 **LLM 서비스 도구(`GeminiLLMTool` 또는 ADK의 LLM 직접 호출 기능)를 호출**합니다. 이때, `오케스트레이터의 LLM 도구 활용 상세 (MVP) - 최종 요약 생성 시 (원본 6.2.3.)`에 정의된 **구체적인 프롬프트**("다음은 아이디어 [...]에 대한 여러 AI 페르소나의 검토 의견입니다. ... 최종 요약 보고서를 작성해주십시오. ... 각 섹션이 명확히 구분되도록 ...")를 사용합니다. 생성된 최종 요약을 UI에 표시할 수 있도록 준비합니다.
        * `오케스트레이터의 LLM 도구 활용 상세 (MVP) (원본 6.2.3.)`:
            * **최종 요약 생성 시**: 입력 데이터(초기 아이디어, 전체 대화 히스토리), 상세 프롬프트, 기대 출력 형식(구조화된 텍스트)을 명확히 하여 LLM을 호출합니다.
    2.  **LLM 서비스 활용 관련 상세 전략 (MVP 추천) (원본 9.)**:
        * `Google ADK 내 LLM 서비스 도구(Tool) 인터페이스 정의 (MCP 개념 적용) (원본 9.2.)`: 오케스트레이터가 최종 요약을 위해 LLM을 호출할 때 사용할 `GeminiLLMTool` 클래스(Python 클래스/메서드 시그니처 예시 참고)를 정의하고 구현하거나, ADK가 제공하는 LLM 직접 호출 기능을 MCP 철학에 맞게 활용합니다. 이 도구는 LLM API 호출 로직을 캡슐화하여 일관성을 유지하고 향후 변경에 유연하게 대응합니다.
        * `API 호출 시 파라미터 최종 값 결정 (원본 9.3.)`: 오케스트레이터가 요약을 생성할 때 사용할 LLM 파라미터(`temperature`는 0.3~0.5로 비교적 낮게, `maxOutputTokens`는 512~1024 정도로 충분히 길게)를 설정합니다.
    3.  **Google ADK 활용 관련 상세 전략 (MVP 추천) (원본 10.)**:
        * `도구(Tool) 정의 및 등록 방식 (ADK BaseTool 활용) (원본 10.4.)`: 만약 `GeminiLLMTool`을 `google.adk.BaseTool`을 상속하여 구현했다면, 이 도구를 ADK에 정식으로 등록하고 오케스트레이터 에이전트가 사용할 수 있도록 `tools` 리스트 매개변수에 전달합니다. 오케스트레이터의 `instruction`에는 이 도구를 언제 어떻게 사용해야 하는지에 대한 지침이 포함될 수 있습니다 (LLM 기반 에이전트가 도구 사용을 결정하는 경우).
    4.  **사용자 인터페이스 (UI) 설계 (MVP 추천: Streamlit 또는 Gradio 활용) (원본 11.)**:
        * `워크숍 진행 화면 (Workshop/Chat Screen) (원본 11.2.2.)`: 모든 페르소나의 의견 제시가 완료되면, **사용자 액션 영역**에 "최종 요약 보기" 버튼을 활성화하여 제시합니다.
        * `최종 요약 보고서 화면 (Summary Report Screen) (원본 11.2.3.)`:
            * **구성 요소**: 워크숍에서 논의된 아이디어 제목 또는 요약, 오케스트레이터 에이전트가 생성한 **최종 요약 보고서 텍스트** (주요 장점, 주요 단점/리스크, 핵심 피드백, 실행 가능한 다음 단계 제안 등의 **구조화된 내용**)를 명확하게 표시합니다.
            * **UX 고려사항**: 정보가 구조화되어 가독성이 높도록 하고, 사용자가 결과를 쉽게 파악할 수 있도록 합니다.
        * `사용자 경험(UX) 흐름 (원본 11.3.)`: ... -> [모든 페르소나 의견 제시 완료] -> [사용자가 "최종 요약 보기" 선택] -> [로딩 인디케이터 후 최종 요약 보고서 화면으로 전환되어 내용 확인]의 흐름을 완성합니다.

## Phase 4: 기본 사용성 개선 및 안정화 (MVP 완성도 향상)

* **목표**: 기본적인 오류 처리 로직을 구현하고, 다양한 테스트를 통해 프롬프트 및 LLM 파라미터를 튜닝하여 응답 품질을 개선합니다. 또한 (선택적으로) 사용자 편의 기능을 추가하여 MVP의 전반적인 완성도와 안정성을 확보합니다.
* **구현 및 참고 아키텍처 항목 상세**:
    1.  **오케스트레이터 에이전트 로직 상세 설계 (MVP - Google ADK 활용) (원본 6.)**:
        * `오류 처리 로직 상세 (MVP 기본) (원본 6.2.4.)`:
            * **A2A 통신 오류 (ADK 내부 호출 오류)**: 페르소나 에이전트 호출 실패 또는 타임아웃 시, 일정 횟수 재시도 로직을 구현합니다(ADK가 지원한다면 해당 기능 활용, 아니면 직접 구현). 재시도 실패 시, 해당 페르소나 의견 누락을 명시하고 진행하거나 사용자에게 오류 알림 후 워크숍 중단 옵션을 제공합니다.
            * **LLM 도구 호출 오류**: LLM 서비스 API 호출 실패 시(API 키, 네트워크, 서비스 다운 등), 재시도 로직을 구현하고, 실패 시 사용자에게 오류 상황을 알리고 잠시 후 다시 시도하도록 안내합니다.
            * **일반적인 예외 처리**: Python의 `try-except` 구문을 사용하여 예상치 못한 오류 발생 시 시스템 비정상 종료를 방지하고 오류 정보를 로깅합니다.
    2.  **페르소나 간 상호작용 방식 (MVP ...) (원본 5.)**:
        * `페르소나 간 의견 충돌 시 처리 방침 (MVP: 사용자에게 판단 위임) (원본 5.3.)`: 최종 요약 생성 시, 만약 페르소나 간 의견이 명확히 상반된 부분이 있다면(MVP에서는 오케스트레이터가 복잡하게 감지하지 않음), 해당 내용을 요약에 포함시키거나, 사용자에게 "이번 워크숍에서는 [페르소나 A]와 [페르소나 B]의 의견이 [특정 주제]에 대해 다소 상반되었습니다..." 와 같이 언급하여 사용자의 비판적 사고를 유도합니다.
    3.  **LLM 서비스 활용 관련 상세 전략 (MVP 추천) (원본 9.)**:
        * `API 호출 시 파라미터 최종 값 결정 (실험 기반 튜닝 필요) (원본 9.3.)`: 다양한 아이디어와 대화 시나리오를 통해 각 페르소나 및 오케스트레이터 요약 시의 **`temperature`, `maxOutputTokens`, `topK`, `topP` 등의 파라미터 값을 지속적으로 테스트하고 평가하여 최적화**합니다. 각 페르소나가 의도한 역할과 스타일에 맞는 응답을 생성하도록 튜닝합니다.
        * `비용 관리 및 모니터링 전략 (원본 9.4.)`: **Google Cloud Console의 Billing 및 API & Services 대시보드를 통해 Gemini API 사용량, 호출 횟수, 발생 비용을 주기적으로 반드시 모니터링**합니다. GCP에서 **예산 알림을 설정**하여 예상치 못한 과도한 비용 발생을 사전에 방지합니다. **프롬프트 최적화, 컨텍스트 윈도우의 효율적 사용, 적절한 `maxOutputTokens` 설정** 등을 통해 토큰 효율성을 극대화합니다. 각 LLM 호출 시 사용된 입출력 토큰 수를 로깅하여 비용 분석에 활용합니다.
        * `프롬프트 엔지니어링 및 관리 (원본 9.5.)`: **시스템 프롬프트의 중요성**을 인지하고, 각 페르소나의 역할, 목표, 말투, 전문 분야, 행동 지침 등을 상세하고 명확하게 기술한 시스템 프롬프트를 지속적으로 개선합니다. 오케스트레이터가 전달할 사용자 프롬프트(아이디어 + 이전 대화 맥락 + 지시사항) 구성도 최적화합니다. 효과적인 프롬프트 조합은 **Git을 통해 버전 관리하거나 DB에 프롬프트 템플릿 형태로 저장**하여 관리합니다.
    4.  **사용자 인터페이스 (UI) 설계 (MVP 추천: Streamlit 또는 Gradio 활용) (원본 11.)**:
        * `UI 목표 (원본 11.1.)`, `사용자 경험(UX) 흐름 (원본 11.3.)`, `디자인 고려사항 (MVP에서는 단순함과 명확성에 집중) (원본 11.5.)` 등을 전반적으로 재검토하고, 사용자의 피드백(가상 또는 실제)을 바탕으로 개선합니다.
        * `워크숍 진행 화면 (Workshop/Chat Screen) (원본 11.2.2.)`의 **UX 고려사항 중 `오류 상황 UI/UX`** (응답 지연/타임아웃 시 안내 메시지 및 재시도 옵션, LLM API 오류/시스템 오류 시 사용자 친화적 메시지 및 오류 코드 안내 등)를 구체적으로 디자인하고 구현합니다.
    5.  **(선택적 기능 구현 시 참고)**:
        * `"다음 단계 제안" 로직 상세화 (MVP 추천) (원본 6.2.2.)`: MVP 고려 옵션이었던 **`2. "아이디어 수정 후 처음부터 다시 검토 시작"`** 기능을 구현합니다.
            * **오케스트레이터 행동**: UI를 통해 사용자로부터 수정된 아이디어를 입력받고, 현재 세션의 `dialogue_history` 처리 방식을 결정(초기화 또는 이전 라운드 요약본만 새 컨텍스트로 저장)합니다. `user_idea`를 수정된 내용으로 업데이트하고 `current_round`를 조정하여 Phase 2부터 다시 시작합니다.
        * `Google ADK 활용 관련 상세 전략 (MVP 추천) (원본 10.)`:
            * `상태 관리(메모리) 메커니즘 구체적 사용법 (ADK session.state 활용) (원본 10.3.)`: (선택적) 워크숍 종료 시 또는 중요한 시점에, `session.state`의 `dialogue_history`, `persona_responses`, 최종 요약 등을 **`Database Access Tool (BaseTool 상속)`을 통해 SQLite 데이터베이스에 저장**하는 기능을 구현합니다. (이를 통해 나중에 세션 이어가기 또는 분석 기능 구현 가능)
            * `도구(Tool) 정의 및 등록 방식 (ADK BaseTool 활용) (원본 10.4.)`: `Database Access Tool (Sessions, Prompts - ADK Tool)`을 `google.adk.BaseTool`을 상속하는 Python 클래스로 구현합니다 (메서드 예시: `save_session_data(session_data: dict)`). 이 도구를 오케스트레이터 에이전트에 등록합니다.
        * `시스템 아키텍처 (원본 3.)`: `External Services & Data Layer`에 `DB_Tool[Database Access Tool (Sessions, Prompts - ADK Tool)]` 컴포넌트를 추가하고, 오케스트레이터 에이전트와의 연결을 명시합니다 (만약 DB 연동 기능 구현 시).

## Phase 5: 확장 및 고도화 (MVP 이후)

* **목표**: MVP의 핵심 기능을 기반으로 사용자 피드백을 반영하여 기능을 확장하고, 시스템의 성능과 안정성을 최적화하며, 장기적인 발전 방향을 모색하여 "AIdea Lab"의 가치를 더욱 높입니다.
* **구현 및 참고 아키텍처 항목 상세 (선택적으로, 우선순위에 따라 진행)**:
    1.  **핵심 철학 (원본 2.)**:
        * **`A2A (Agent-to-Agent) Protocol - 표준화된 에이전트 간 협력 (외부 연동 시 고려)`**: Google의 개방형 A2A 프로토콜을 본격적으로 연구하고, "AIdea Lab" 시스템이 향후 외부의 다른 A2A 호환 에이전트와 연동하거나 자체 기능을 외부 시스템에 서비스로 제공할 때 이 프로토콜을 준수하도록 시스템을 확장하는 것을 목표로 합니다.
    2.  **시스템 아키텍처 (원본 3.)**:
        * `External Services & Data Layer (Accessed via ADK Tools - MCP)` 내 `Future Expansion (ADK Tools)`: `External Data API Tools (e.g., Market Research - ADK Tool)`와 같은 새로운 ADK 도구를 개발하여, 특정 페르소나(예: 비판적 분석가)가 외부 시장 조사 API나 특허 정보 API를 호출하여 분석의 깊이를 더할 수 있도록 기능을 확장합니다.
    3.  **페르소나 간 상호작용 방식 중 확장 옵션 (원본 5.2. 하위)**:
        * **`(향후 확장 옵션 예시)`**: Google ADK의 **라우터 에이전트 기능을 활용하여 특정 주제에 대한 심층 논의를 유도**하거나, 사용자가 **새로운 유형의 페르소나 ADK Agent를 동적으로 추가**하여 워크숍에 참여시킬 수 있는 기능을 개발합니다.
    4.  **1인 개발 시 단계별 접근 방안 (MVP 중심 - Google ADK 활용) 중 확장 (원본 8.의 5단계)**: Google ADK의 고급 기능(라우터 에이전트, 추가 도구 연동 메커니즘 심화 학습 등)을 학습하고 프로젝트에 적용하는 것을 고려합니다.
    5.  **Google ADK 활용 관련 상세 전략 (MVP 추천) (원본 10.)**:
        * `상태 관리(메모리) 메커니즘 구체적 사용법 (ADK session.state 활용) (원본 10.3.)`: 매우 긴 대화가 발생하는 경우, 전체 `dialogue_history`를 모든 `LlmAgent`의 `instruction`에 포함시키는 것의 비효율성을 해결하기 위해, 오케스트레이터(또는 별도의 요약 `LlmAgent`)가 **주기적으로 `dialogue_history`를 요약하여 `session.state['dialogue_summary']`와 같이 저장**하고, 페르소나들은 이 요약본을 참조하도록 하는 고급 메모리 관리 로직을 구현합니다. ADK가 메모리 요약 관련 유틸리티나 Planner 기능을 제공하는지 확인하고 활용합니다.
        * `Google ADK 기반 테스트 및 평가 도구 활용 계획 (MVP 이후 고려) (원본 10.5.)`: Google ADK가 에이전트 테스트, 평가, 디버깅을 위한 내장 도구나 프레임워크를 제공하는지 확인하고 적극 활용합니다. 다양한 아이디어 입력에 대한 **테스트 케이스를 정의**하고, 응답의 관련성, 일관성, 페르소나 역할 충실도 등의 **평가 지표(정성적/정량적)를 설정**하여 시스템을 평가합니다. 가능하다면 일부 핵심 기능에 대한 **테스트 케이스를 자동화**하여 회귀 테스트에 활용합니다.
    6.  **사용자 인터페이스 (UI) 설계 (MVP 추천: Streamlit 또는 Gradio 활용) (원본 11.)**:
        * `시작 화면 (Home/Welcome Screen) (원본 11.2.1.)`: 사용자가 **이전 워크숍 세션을 불러올 수 있는 기능**을 추가합니다 (DB 연동 기능이 선행되어야 함).
        * `최종 요약 보고서 화면 (Summary Report Screen) (원본 11.2.3.)`: 사용자가 최종 요약 내용을 쉽게 **복사하거나 저장(텍스트 파일 등)할 수 있는 버튼**, 또는 **PDF 다운로드 버튼**과 같은 편의 기능을 추가합니다.
        * UI 기술 스택 확장: 사용성 및 확장성을 위해 MVP에서 사용한 Streamlit/Gradio 대신 **React/Next.js (프론트엔드) + FastAPI/Flask (백엔드 API 서버) 등으로 UI 시스템을 재구축하거나 확장**하는 것을 고려합니다.

---
