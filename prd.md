# 프로젝트: AIdea Lab (Google ADK & A2A Protocol 기반)

## 1. 프로젝트 목표
(이전 내용과 동일)
사용자가 아이디어를 입력하면, 다양한 AI 페르소나 에이전트들이 각자의 관점에서 아이디어를 분석, 검증하고 발전 방향을 제안하는 대화형 가상 워크숍 환경을 제공한다. 모든 에이전트는 Google ADK(Agent Development Kit)를 사용하여 개발 및 관리된다.

## 2. 핵심 철학
(이전 내용과 동일)
* **A2A (Agent-to-Agent) Protocol - 표준화된 에이전트 간 협력 (외부 연동 시 고려):**
    * "AIdea Lab" 시스템이 향후 외부의 다른 A2A 호환 에이전트와 연동하거나, 자체 기능을 외부 시스템에 서비스로 제공할 때 Google의 개방형 A2A 프로토콜 준수를 목표로 한다.
    * (MVP 단계에서는 ADK 내부 통신 메커니즘을 우선 활용한다.)
* **Google ADK (Agent Development Kit) - 통합 에이전트 개발 및 오케스트레이션**:
    * "AIdea Lab"의 모든 에이전트는 Google ADK를 사용하여 설계, 개발, 배포 및 관리된다.
    * ADK가 제공하는 워크플로우 에이전트, 라우팅 기능, 도구 통합 메커니즘, 상태 관리 등을 활용하여 오케스트레이터 및 페르소나 에이전트를 효율적으로 구현한다.
    * LLM(Gemini 2.5 Flash) 연동, 프롬프트 관리, 대화 메모리 등도 ADK의 기능을 통해 관리한다.
* **MCP (Model-Context Protocol) - 외부 정보/도구 연동 표준화 (ADK Tool 메커니즘 활용)**:
    * LLM API 호출을 포함한 모든 외부 서비스(API, 데이터베이스 등) 접근은 Google ADK의 **'도구(Tool)'** 메커니즘을 통해 이루어진다.
    * 각 도구는 표준화된 인터페이스를 가지며, 에이전트가 필요에 따라 호출하여 외부 컨텍스트를 활용한다. 이는 MCP의 철학을 ADK 환경 내에서 구현하는 방식이다.

## 3. 시스템 아키텍처

### 3.1. 시스템 개요도 (High-Level Architecture - Google ADK 기반)

```mermaid
graph LR
    subgraph "User Interaction Layer"
        UI[User Interface (Web App / CLI)]
    end

    subgraph "Core Agent System (Google ADK)"
        Orchestrator_ADK[Orchestrator Agent (Google ADK Workflow/Router Agent)]
        subgraph "AI Persona Agent Pool (Google ADK Specialized Agents)"
            direction LR
            P_Critic_ADK[Critic Persona Agent (ADK Agent)]
            P_Marketer_ADK[Marketer Persona Agent (ADK Agent)]
            P_Engineer_ADK[Engineer Persona Agent (ADK Agent)]
            P_Etc_ADK[... (Other ADK Personas)]
        end
    end

    subgraph "External Services & Data Layer (Accessed via ADK Tools - MCP)"
        LLM_Service_Tool[LLM Service Tool (Gemini 2.5 Flash - ADK Tool)]
        subgraph "Future Expansion (ADK Tools)"
            direction TB
            External_Data_Tools[External Data API Tools (e.g., Market Research - ADK Tool)]
            DB_Tool[Database Access Tool (Sessions, Prompts - ADK Tool)]
        end
    end

    %% Connections
    UI <-->|User Input & Displayed Dialogue via API| Orchestrator_ADK

    %% ADK Internal Communication between Orchestrator and Persona Agents
    Orchestrator_ADK -- ADK Internal Call / Dataflow --> P_Critic_ADK
    Orchestrator_ADK -- ADK Internal Call / Dataflow --> P_Marketer_ADK
    Orchestrator_ADK -- ADK Internal Call / Dataflow --> P_Engineer_ADK
    Orchestrator_ADK -- ADK Internal Call / Dataflow --> P_Etc_ADK

    P_Critic_ADK -- ADK Internal Call / Dataflow --> Orchestrator_ADK
    P_Marketer_ADK -- ADK Internal Call / Dataflow --> Orchestrator_ADK
    P_Engineer_ADK -- ADK Internal Call / Dataflow --> Orchestrator_ADK
    P_Etc_ADK -- ADK Internal Call / Dataflow --> Orchestrator_ADK

    %% ADK Agents utilize Tools (MCP) to access external services
    Orchestrator_ADK -->|Uses Tool| LLM_Service_Tool
    P_Critic_ADK -->|Uses Tool| LLM_Service_Tool
    P_Marketer_ADK -->|Uses Tool| LLM_Service_Tool
    P_Engineer_ADK -->|Uses Tool| LLM_Service_Tool
    P_Etc_ADK -->|Uses Tool| LLM_Service_Tool

    Orchestrator_ADK -->|Uses Tool| DB_Tool
    %% Future Tool Usage
    %% P_Critic_ADK ---|Uses Tool| External_Data_Tools

### 3.2. 개요도 설명 (Google ADK 중심)

* **User Interaction Layer (사용자 상호작용 계층)**:
    * `User Interface (Web App / CLI)`: 사용자가 시스템과 직접 상호작용하는 부분입니다. 아이디어를 입력하고, AI 페르소나들과의 대화 내용을 확인하며, 다음 단계 진행 여부 등을 선택합니다.
* **Core Agent System (Google ADK) (핵심 에이전트 시스템)**:
    * 이 시스템 내의 모든 에이전트(오케스트레이터, 페르소나)는 Google ADK를 사용하여 구축됩니다.
    * 에이전트 간의 상호작용은 주로 **ADK가 제공하는 내부 통신 및 오케스트레이션 메커니즘**(예: 워크플로우 에이전트를 통한 호출, 공유 세션 상태(`session.state`), LLM 기반 위임(`transfer_to_agent`), `AgentTool`을 이용한 명시적 호출 등)을 통해 이루어집니다.
    * 향후 "AIdea Lab"이 외부의 다른 프레임워크로 구축된 에이전트와 연동하거나 자체 기능을 외부 서비스로 제공해야 할 경우, Google의 개방형 A2A 프로토콜 도입을 고려할 수 있습니다.
    * `Orchestrator Agent (Google ADK Workflow/Router Agent)`: Google ADK의 워크플로우 또는 라우터 에이전트 기능을 사용하여 구현. 전체 워크숍 세션 관리, ADK 내부 메커니즘을 통한 페르소나 에이전트 호출 및 응답 처리, 대화 흐름 제어, 상태(메모리) 관리, 최종 결과 요약 등을 담당. LLM 서비스 도구(Tool)를 사용하여 자체적인 판단이나 요약 수행.
    * `AI Persona Agent Pool (Google ADK Specialized Agents)`: 각 페르소나는 Google ADK의 특화된 에이전트로 구현. 고유한 시스템 프롬프트와 역할을 부여받고, 오케스트레이터의 요청에 따라 LLM 서비스 도구(Tool)를 사용하여 응답 생성. ADK 내부 메커니즘을 통해 오케스트레이터와 통신.
        * `Critic Persona Agent (ADK Agent)`
        * `Marketer Persona Agent (ADK Agent)`
        * `Engineer Persona Agent (ADK Agent)`
        * `... (Other ADK Personas)`
* **External Services & Data Layer (Accessed via ADK Tools - MCP) (외부 서비스 및 데이터 계층 - ADK 도구 통해 접근)**:
    * `LLM Service Tool (Gemini 2.5 Flash - ADK Tool)`: Gemini 2.5 Flash LLM API 호출을 담당하는 Google ADK의 '도구(Tool)'. 모든 에이전트는 이 도구를 통해 LLM 기능을 사용.
    * `Database Access Tool (Sessions, Prompts - ADK Tool)`: 워크숍 세션 정보, 대화 기록, 프롬프트 템플릿 등을 저장하고 조회하는 ADK '도구(Tool)'.
    * `External Data API Tools (Future Expansion - ADK Tool)`: 향후 연동될 외부 데이터 소스(시장 조사, 특허 정보 등) 접근을 위한 ADK '도구(Tool)'.

### 3.3. 주요 상호작용 흐름 (Google ADK 내부 메커니즘 기반)
1.  **UI -> Orchestrator Agent**: 사용자가 아이디어를 입력하면, UI는 오케스트레이터 에이전트의 API를 호출하여 워크숍 시작 요청.
2.  **Orchestrator Agent**: 세션 시작, 상태(메모리) 초기화. ADK 워크플로우 로직에 따라 첫 번째 페르소나 에이전트에게 **ADK 내부 호출 방식 (예: 워크플로우를 통해)** 작업 요청 (아이디어, 이전 대화 맥락, 지시사항 등 포함).
3.  **Persona Agent**: 요청 수신 후, 자신의 역할과 프롬프트에 따라 **LLM 서비스 도구(Tool)**를 사용하여 응답 생성. 생성된 응답을 **ADK 내부 메커니즘 (예: 워크플로우 결과 반환 또는 공유 상태 업데이트)**을 통해 오케스트레이터에게 반환.
4.  **Orchestrator Agent**: 페르소나의 응답 수신, 상태(메모리) 업데이트. 해당 응답을 UI에 전달.
5.  **Orchestrator Agent**: ADK 워크플로우 로직에 따라 다음 페르소나에게 내부적으로 요청을 보내거나, 사용자에게 다음 단계 옵션을 제시하는 등 대화 흐름 제어. (3-4단계 반복)
6.  **워크숍 종료**: 오케스트레이터는 **LLM 서비스 도구(Tool)**를 사용하여 전체 대화 요약 후 UI에 전달. **데이터베이스 접근 도구(Tool)**를 사용하여 세션 정보 저장.

### 3.4. 주요 구성 요소 상세 (기술 스택 중심 요약 - Google ADK 기반)
*   **User Interface (UI)**: (MVP: Streamlit/Gradio, 확장: React/Next.js + FastAPI/Flask)
*   **Orchestrator Agent & AI Persona Agents**: (기술: Python + **Google ADK**, A2A Protocol)
*   **LLM Service Tool & Other External Tools**: (기술: **Google ADK Tool** 메커니즘, 각 API 클라이언트 라이브러리)
*   **Database Access Tool**: (기술: **Google ADK Tool** 메커니즘, DB 드라이버)
*   **LLM**: Google Gemini 2.5 Flash (또는 사용 가능한 최신 Flash 계열 Gemini 모델)

## 4. AI 페르소나 정의 (MVP: 3가지 핵심 페르소나 - Google ADK Agent로 구현)

### 4.1. 비판적 분석가 (The Critic/Analyst)
*   **역할**: 아이디어의 논리적 허점, 잠재적 위험, 실현 가능성 걸림돌, 시장 진입 장벽 등 분석/지적. 객관적 평가.
*   **목표**: 아이디어의 문제점/약점 인지 지원, 과도한 낙관론 경계, 아이디어 견고화 자극.
*   **말투/스타일**: 직설적, 명료, 객관적, 분석적, 질문 중심, 약간의 회의적 시각.
*   **전문 분야**: 논리/비판적 사고, 리스크 분석, 데이터 분석 기초, 사업 타당성 검토, 문제 해결.

### 4.2. 창의적 마케터 (The Creative Marketer/Innovator)
*   **역할**: 아이디어의 독창적 가치, 새로운 시장 기회, 매력 포인트, 차별화 전략 발굴/제안. 상상력과 긍정 에너지 주입.
*   **목표**: 아이디어 잠재력 확장, 숨겨진 가치 발견, 영감 제공, 아이디어 매력도 향상, 독창적 방법 모색.
*   **말투/스타일**: 열정적, 긍정적, 상상력 풍부, 비유적 표현, 개방형 질문/제안, 에너지 넘치는 설득력.
*   **전문 분야**: 창의적 사고, 마케팅 전략, 브랜딩, 트렌드 분석, 스토리텔링, 가치 제안.

### 4.3. 현실적 엔지니어/개발자 (The Pragmatic Engineer/Developer)
*   **역할**: 기술적 구현 가능성, 필요 기술 스택, 개발 어려움, 프로토타입 제작 방안 등 구체적 검토. 실제 구현 단계/자원 현실적 제시.
*   **목표**: 기술적 실현 가능성/장벽 명확화, 구체적 실행 계획 수립 지원, MVP 정의, 개발 우선순위 설정 도움.
*   **말투/스타일**: 실용적, 구체적, 논리적, 체계적, 건설적 질문, 차분하고 문제 해결 중심.
*   **전문 분야**: 개발 프로세스, 프로그래밍/기술 스택, 시스템 아키텍처, 프로토타이핑/MVP, 기술적 문제 해결.

## 5. 페르소나 간 상호작용 방식 (MVP: "Google ADK 워크플로우 기반 순차적 의견 교환 및 참조" + 확장성 고려)

### 5.1. 핵심 아이디어
*   **오케스트레이터 에이전트(Google ADK 워크플로우 에이전트)가 사회자/진행자 역할**: 전체 대화 흐름을 Google ADK의 워크플로우 정의에 따라 주도합니다.
*   **순차적 발언 및 이전 의견 명시적 참조 (기본 라운드)**: Google ADK 워크플로우는 정의된 순서대로 각 페르소나 ADK Agent에게 A2A 프로토콜을 통해 발언을 요청합니다. 이때, 오케스트레이터는 이전 페르소나(들)의 발언 내용(또는 요약)을 현재 페르소나에게 전달하여 참고하도록 합니다. 각 페르소나의 시스템 프롬프트에도 이러한 참고 지시사항이 포함됩니다.
*   **사용자 개입 최소화 (초기 MVP)**: 워크플로우가 진행되는 동안 사용자의 직접적인 개입은 최소화되며, 주로 라운드 종료 후 "다음 단계"를 선택하는 형태로 상호작용합니다.
*   **라운드 종료 후 "다음 단계 제안" (확장성 핵심)**: 오케스트레이터는 기본 라운드(모든 페르소나가 1회씩 발언) 종료 후, 사용자에게 여러 "다음 단계" 옵션을 제안합니다. 이를 통해 단순 종료 외에 심층 논의나 반복적 개선 과정을 유도할 수 있는 확장성을 확보합니다.

### 5.2. 구체적인 작동 방식 예시 (기본 라운드 + 다음 단계 제안)
1.  사용자 아이디어 입력.
2.  오케스트레이터 ADK 워크플로우가 순서대로 `창의적 마케터 ADK Agent` -> `비판적 분석가 ADK Agent` -> `현실적 엔지니어 ADK Agent`를 A2A 프로토콜로 호출.
3.  각 페르소나 ADK Agent는 이전 페르소나(들)의 의견을 포함한 정보를 받아 LLM 서비스 도구를 사용하여 자신의 의견 생성 후 A2A로 응답.
4.  모든 페르소나 발언 후, 오케스트레이터가 사용자에게 다음 단계 옵션 제시:
    *   **옵션 1 (필수 MVP): "워크숍 종료 및 최종 요약 보기"**
    *   **옵션 2 (MVP 고려): "아이디어 수정 후 처음부터 다시 검토 시작"**
    *   **(향후 확장 옵션 예시):** ADK 라우터 에이전트 활용한 심층 논의, 새 페르소나 ADK Agent 추가 등.

### 5.3. 페르소나 간 의견 충돌 시 처리 방침 (MVP: 사용자에게 판단 위임)
*   **충돌 인지 (MVP에서는 단순화)**: MVP 단계에서는 오케스트레이터가 명시적으로 의견 충돌을 복잡하게 감지하고 분석하는 로직은 포함하지 않습니다. 사용자가 대화 내용을 보고 의견이 상반됨을 인지하는 것을 가정합니다.
*   **처리 방식**: 만약 페르소나 간 의견이 명확히 상반될 경우 (예: 한 페르소나는 "매우 긍정적", 다른 페르소나는 "매우 부정적"으로 평가), 오케스트레이터는 최종 요약 시 해당 내용을 포함하거나, "다음 단계 제안" 시 사용자에게 다음과 같은 질문을 추가하여 판단을 유도할 수 있습니다:
    *   "이번 워크숍에서는 [페르소나 A]와 [페르소나 B]의 의견이 [특정 주제]에 대해 다소 상반되었습니다. 이 부분에 대해 어떻게 생각하시는지, 또는 어떤 의견을 더 중요하게 고려하고 싶으신지 등을 바탕으로 아이디어를 발전시켜 보시는 것도 좋겠습니다."
    *   또는, 사용자가 "아이디어 수정 후 재검토"를 선택할 때, "특히 어떤 페르소나의 의견을 중점적으로 반영하여 수정하셨나요?" 와 같은 질문을 통해 사용자의 판단을 다음 라운드에 참고하도록 유도할 수 있습니다.
*   **추천 이유 (MVP 관점)**:
    *   **구현 단순성**: 복잡한 충돌 감지 및 중재 로직 없이, 오케스트레이터는 주로 정보 전달 및 요약 역할에 집중할 수 있습니다.
    *   **사용자 주도성 존중**: 최종 판단은 사용자의 몫으로 남겨두어, 사용자가 다양한 의견을 비판적으로 수용하고 스스로 결론을 내리도록 합니다.
    *   **확장 가능성**: 향후 오케스트레이터가 더 능동적으로 충돌을 감지하고 다양한 중재 옵션을 제공하는 방식으로 발전시킬 수 있는 여지를 남겨둡니다.

## 6. 오케스트레이터 에이전트 로직 상세 설계 (MVP - Google ADK 활용)

### 6.1. 핵심 역할 및 책임 (Google ADK 에이전트로서)
*   (이전 내용과 동일 - 생략 가능 또는 필요시 간략히 재언급)
    *   초기 아이디어 수신 및 세션 관리 (ADK 상태 관리 기능 활용).
    *   정의된 AI 페르소나 ADK Agent들에게 A2A 프로토콜로 순차적 발언 요청.
    *   각 페르소나에게 전달할 정보 구성.
    *   A2A 응답 수신 및 대화 기록(ADK 메모리/상태) 관리.
    *   라운드 종료 후 "다음 단계" 옵션 제시.
    *   사용자 선택에 따른 워크숍 종료/요약 또는 다음 단계 진행.

### 6.2. 대화 흐름 제어 방식 (MVP: "Google ADK 고정 순서 워크플로우 + 라운드 종료 후 선택적 반복")

#### 6.2.1. Google ADK 워크플로우 상세 설계 (MVP 추천: 순차 실행 워크플로우 에이전트)

*   **사용 ADK 기능 (가정)**: Google ADK가 제공하는 **순차 실행 워크플로우 에이전트 (Sequential Workflow Agent)** 또는 이와 유사한 기능을 사용합니다. 이 에이전트는 미리 정의된 순서대로 하위 에이전트(여기서는 페르소나 에이전트)들을 순차적으로 호출하고, 각 단계의 출력을 다음 단계의 입력으로 전달하거나, 오케스트레이터가 중앙에서 관리하는 공유 상태(메모리)를 업데이트하는 방식으로 작동합니다.
*   **워크플로우 단계 정의**:
    1.  **[시작] 사용자 아이디어 입력 수신**:
        *   UI로부터 사용자 아이디어와 함께 워크숍 시작 요청을 받습니다.
        *   오케스트레이터는 세션 ID를 생성하고, ADK 상태 관리 기능을 통해 `user_idea`, `dialogue_history` (초기에는 비어 있음), `current_round = 1` 등의 초기 상태를 설정합니다.
    2.  **[1단계] 창의적 마케터 의견 수렴**:
        *   **A2A 요청**: `창의적 마케터 ADK Agent`에게 A2A 프로토콜로 작업 요청.
            *   **전달 메시지 (스키마 예시 - 추후 확정 필요)**:
                ```json
                {
                  "session_id": "세션ID",
                  "task_type": "ANALYZE_IDEA_CREATIVE_MARKETING",
                  "idea_text": "사용자 아이디어 텍스트",
                  "previous_dialogue_summary": null // 첫 번째 페르소나이므로 이전 대화 없음
                }
                ```
            *   **요청 지시사항 (프롬프트 일부로 구성)**: "주어진 아이디어에 대해 시장 잠재력과 독창적인 활용 방안을 중심으로 의견을 제시해주십시오."
        *   **A2A 응답 수신**: 마케터 에이전트로부터 응답 메시지(예: 생성된 텍스트) 수신.
        *   **상태 업데이트**: `dialogue_history`에 마케터의 의견 추가.
    3.  **[2단계] 비판적 분석가 의견 수렴**:
        *   **A2A 요청**: `비판적 분석가 ADK Agent`에게 A2A 프로토콜로 작업 요청.
            *   **전달 메시지 (스키마 예시)**:
                ```json
                {
                  "session_id": "세션ID",
                  "task_type": "ANALYZE_IDEA_CRITICAL_ANALYSIS",
                  "idea_text": "사용자 아이디어 텍스트",
                  "previous_dialogue_summary": "창의적 마케터의 주요 의견 요약 또는 전체" // ADK 상태에서 가져오거나 LLM 도구로 요약
                }
                ```
            *   **요청 지시사항**: "주어진 아이디어와 이전 마케터의 의견을 참고하여, 잠재적인 문제점이나 리스크를 분석해주십시오."
        *   **A2A 응답 수신**: 분석가 에이전트로부터 응답 메시지 수신.
        *   **상태 업데이트**: `dialogue_history`에 분석가의 의견 추가.
    4.  **[3단계] 현실적 엔지니어 의견 수렴**:
        *   **A2A 요청**: `현실적 엔지니어 ADK Agent`에게 A2A 프로토콜로 작업 요청.
            *   **전달 메시지 (스키마 예시)**:
                ```json
                {
                  "session_id": "세션ID",
                  "task_type": "ANALYZE_IDEA_TECHNICAL_FEASIBILITY",
                  "idea_text": "사용자 아이디어 텍스트",
                  "previous_dialogue_summary": "마케터 및 분석가의 주요 의견 요약 또는 전체"
                }
                ```
            *   **요청 지시사항**: "주어진 아이디어와 이전 페르소나들의 의견을 종합적으로 고려하여 기술적 실현 가능성과 주요 과제를 검토해주십시오."
        *   **A2A 응답 수신**: 엔지니어 에이전트로부터 응답 메시지 수신.
        *   **상태 업데이트**: `dialogue_history`에 엔지니어의 의견 추가.
    5.  **[라운드 종료] "다음 단계 제안" 로직 실행**:
        *   모든 페르소나의 1차 발언이 완료되었으므로, 사용자에게 "다음 단계" 옵션을 UI를 통해 제시합니다.
        *   (이 로직은 다음 섹션에서 더 상세히 다룹니다.)
*   **A2A 프로토콜 메시지 스키마 (초안 - 추후 확정 필요)**:
    *   오케스트레이터와 페르소나 에이전트 간에 주고받을 A2A 메시지의 기본적인 필드 구조를 정의합니다. (예: `session_id`, `source_agent_id`, `target_agent_id`, `task_type`, `payload`, `timestamp` 등). Google ADK가 권장하거나 제공하는 스키마가 있다면 그것을 따릅니다.
*   **상태 관리 (ADK 기능 활용)**:
    *   Google ADK가 제공하는 상태 관리 메커니즘(예: 세션별 컨텍스트 저장소)을 사용하여 `dialogue_history`, `user_idea`, `current_round` 등의 주요 정보를 관리합니다.
    *   긴 대화의 경우, `dialogue_history`를 LLM 도구를 사용하여 주기적으로 요약하여 상태 크기를 관리하는 방안도 고려할 수 있습니다 (MVP에서는 전체 히스토리 전달 우선).

#### 6.2.2. "다음 단계 제안" 로직 상세화 (MVP 추천)

*   **옵션 제시 조건**: 기본 라운드(3명의 페르소나가 모두 1회씩 발언)가 성공적으로 완료된 경우.
*   **제시 옵션 (UI를 통해 사용자에게 선택지로 제공)**:
    1.  **"워크숍 종료 및 최종 요약 보기"**:
        *   **오케스트레이터 행동**:
            *   현재까지의 `dialogue_history` 전체 또는 주요 내용을 입력으로 하여 **LLM 서비스 도구(Tool)**를 호출.
            *   LLM에 전달할 프롬프트 예시: "다음은 아이디어 [사용자 아이디어]에 대한 여러 AI 페르소나(마케터, 분석가, 엔지니어)의 검토 의견입니다. 이 전체 내용을 종합하여 아이디어의 주요 장점, 단점, 핵심 피드백, 그리고 실행 가능한 다음 단계 제안을 포함하는 최종 요약 보고서를 작성해주십시오. 보고서는 각 섹션이 명확히 구분되도록 작성해주십시오."
            *   생성된 최종 요약 보고서를 UI에 표시.
            *   워크숍 세션 종료 처리 (데이터베이스 접근 도구를 사용하여 세션 정보 저장).
    2.  **"아이디어 수정 후 처음부터 다시 검토 시작"**:
        *   **오케스트레이터 행동**:
            *   UI를 통해 사용자로부터 수정된 아이디어를 입력받습니다.
            *   현재 세션의 `dialogue_history`를 처리하는 방식 결정 (예: 초기화, 또는 이전 라운드 요약본만 새 `user_idea_context`로 저장하여 다음 라운드에 참고하도록 제공).
            *   `user_idea`를 수정된 내용으로 업데이트.
            *   `current_round`를 1 증가시키거나, 새로운 세션으로 간주하여 다시 1로 설정.
            *   위의 "6.2.1. 워크플로우 단계 정의"의 2단계(`창의적 마케터 의견 수렴`)부터 다시 시작.
*   **사용자 선택 처리**: 사용자가 UI에서 옵션을 선택하면, 오케스트레이터는 해당 옵션에 정의된 로직을 수행합니다.

#### 6.2.3. 오케스트레이터의 LLM 도구 활용 상세 (MVP)

*   **최종 요약 생성 시**:
    *   **입력**: 전체 대화 히스토리 (또는 주요 부분), 사용자의 초기 아이디어.
    *   **프롬프트**: 위 "다음 단계 제안" 로직에서 예시로 든 프롬프트와 같이, 명확한 지시사항과 원하는 출력 형식을 포함하여 작성.
    *   **출력**: 구조화된 최종 요약 보고서 텍스트.
*   **(선택적) 대화 히스토리 요약 시**:
    *   긴 대화 히스토리를 다음 페르소나에게 전달하기 전에 요약해야 할 경우, LLM 도구를 호출.
    *   프롬프트 예시: "다음 대화 내용을 핵심만 간추려 300단어 이내로 요약해주십시오. 아이디어: [...], 대화 내용: [...]"

#### 6.2.4. 오류 처리 로직 상세 (MVP 기본)

*   **A2A 통신 오류**: 페르소나 에이전트 호출 실패 또는 타임아웃 시,
    *   일정 횟수 재시도 로직 구현 (Google ADK가 지원한다면 활용).
    *   재시도 실패 시, 해당 페르소나의 의견은 누락되었음을 명시하고 다음 단계로 진행하거나, 사용자에게 오류 알림 후 워크숍 중단 옵션 제공.
*   **LLM 도구 호출 오류**: LLM 서비스 API 호출 실패 시 (예: API 키 오류, 네트워크 문제, 서비스 다운),
    *   재시도 로직 구현.
    *   재시도 실패 시, 사용자에게 오류 상황 알리고 잠시 후 다시 시도하도록 안내.
*   **일반적인 예외 처리**: Python의 `try-except` 구문을 사용하여 예상치 못한 오류 발생 시 시스템이 비정상 종료되지 않도록 하고, 오류 정보를 로깅.

### 6.3. 사용자 입력 처리 방식 (MVP: "초기 아이디어 입력 + 다음 단계 선택")
*   (이전 내용과 동일 - 생략 가능 또는 필요시 간략히 재언급)
    *   워크숍 시작 시 아이디어 입력.
    *   진행 중 사용자 개입 최소화.
    *   라운드 종료 후 제시된 옵션 중 사용자가 다음 행동 선택.

## 7. 기술 스택 (1인 개발자 추천 - MVP, Google ADK 중심)
*   **주요 언어**: Python (Google ADK가 지원하는 주 언어일 가능성 높음)
*   **ADK**: **Google ADK**
*   **LLM**: Google Gemini 2.5 Flash (또는 사용 가능한 최신 Flash 계열 Gemini 모델) - **Google ADK의 LLM 서비스 도구를 통해 접근**
*   **UI**: Streamlit 또는 Gradio
*   **데이터베이스**: SQLite (또는 Google ADK가 추천하거나 쉽게 연동 가능한 DB) - **Google ADK의 데이터베이스 접근 도구를 통해 접근**
*   **배포**: Google ADK가 지원하는 배포 환경 (예: Vertex AI Agent Engine, Cloud Run, Docker)

## 8. 1인 개발 시 단계별 접근 방안 (MVP 중심 - Google ADK 활용)
1.  **1단계 (Google ADK 학습 및 기본 에이전트 구현)**:
    *   Google ADK 공식 문서 학습 및 개발 환경 설정.
    *   단일 AI 페르소나 ADK Agent (예: 비판가)와 사용자의 아이디어에 대한 1회성 질의응답 기능 구현. (ADK의 기본 에이전트 및 LLM 도구 활용)
    *   간단한 UI(CLI/Streamlit) 연동.
2.  **2단계 (멀티 페르소나 및 순차적 워크플로우)**:
    *   2~3개 페르소나 ADK Agent 정의.
    *   Google ADK의 워크플로우 에이전트 기능을 사용하여 오케스트레이터가 순차적으로 각 페르소나를 A2A 호출하도록 구현.
    *   ADK의 상태 관리 기능을 활용한 간단한 대화 메모리 추가.
3.  **3단계 (오케스트레이션 강화 및 "다음 단계 제안")**:
    *   라운드 종료 후 "다음 단계 제안" 로직 추가.
    *   페르소나별 시스템 프롬프트 고도화 (ADK 설정 방식 활용).
4.  **4단계 (UI 개선 및 부가 기능)**:
    *   채팅 UI 개선.
    *   세션 저장/로드 기능 (ADK의 데이터베이스 접근 도구 활용).
    *   최종 요약 기능 (오케스트레이터가 LLM 도구 활용).
5.  **5단계 (확장 - 선택적)**:
    *   Google ADK의 고급 기능(라우터 에이전트, 추가 도구 연동 등) 학습 및 적용 고려.
    *   A2A 프로토콜을 활용한 외부 에이전트와의 연동 가능성 탐색.


    ## 9. LLM 서비스 (Gemini 2.5 Flash 또는 유사 모델) 활용 관련 상세 전략 (MVP 추천)

### 9.1. LLM 모델 및 API 최종 확인 (필수 선행 작업)
*   **모델명 및 버전 확정**: 현재 시점(2025년 5월) 기준으로 "Gemini 2.5 Flash"라는 모델이 일반 개발자에게 안정적인 API 형태로 제공되는지, 아니면 "Gemini 1.5 Flash" 또는 다른 최신 Flash 계열 모델을 사용해야 하는지 Google의 공식 문서를 통해 **반드시 최종 확인**합니다. 이 문서에서는 현재 사용 가능한 최적의 Flash 계열 Gemini 모델을 지칭하는 것으로 가정합니다.
*   **API 엔드포인트 및 인증 방식 확인**: 선택된 Gemini 모델의 정확한 API 엔드포인트, 요청/응답 형식, 인증 방법(API 키, 서비스 계정 등)을 공식 문서에서 확인합니다.
*   **호출 제한 (Quotas) 및 비용 정책 숙지**: 분당/일일 API 호출 수 제한, 토큰당 비용(입력/출력 토큰 구분) 등을 명확히 파악하여 예산 및 시스템 설계에 반영합니다.

### 9.2. Google ADK 내 LLM 서비스 도구(Tool) 인터페이스 정의 (MCP 개념 적용)
*   **도구의 역할**: 모든 에이전트(오케스트레이터, 페르소나)가 Gemini LLM을 일관되고 표준화된 방식으로 호출할 수 있도록 하는 Google ADK의 '도구(Tool)'를 정의합니다.
*   **도구 인터페이스 (Python 클래스/메서드 시그니처 예시 - 실제 ADK 방식에 따라 조정)**:
    ```python
    class GeminiLLMTool:
        def __init__(self, api_key: str, model_name: str = "gemini-x.x-flash"): # 실제 모델명으로 변경
            # API 클라이언트 초기화 (예: Google AI Python SDK 사용)
            # self.client = ...
            self.model_name = model_name

        def generate_response(
            self,
            prompt_parts: list, # Gemini API는 텍스트, 이미지 등 다양한 파트의 리스트를 받을 수 있음 (MVP는 텍스트만)
            system_instruction: str = None, # 모델의 역할이나 행동 지침을 담는 시스템 메시지
            temperature: float = 0.7,
            max_output_tokens: int = 512,
            top_k: int = None,
            top_p: float = None
            # 기타 Gemini API 관련 설정 파라미터들...
        ) -> str:
            # 1. Gemini API 요청 형식에 맞게 입력 구성
            #    (prompt_parts, system_instruction 등을 API가 요구하는 형태로 변환)
            # 2. API 호출 및 응답 수신
            # 3. 응답에서 텍스트 추출 및 반환
            # 4. 오류 처리 (API 에러, 타임아웃 등)
            pass
    ```
*   **ADK에 도구 등록**: Google ADK가 제공하는 방식에 따라 위와 같이 정의된 LLM 서비스 도구를 등록하여, 오케스트레이터 및 페르소나 에이전트가 이 도구를 호출하여 사용할 수 있도록 합니다.
*   **이점**:
    *   LLM API 호출 로직을 중앙에서 관리 (코드 중복 방지, 일관성 유지).
    *   향후 다른 LLM 모델이나 서비스로 변경 시, 이 도구의 내부 구현만 수정하면 되므로 유연성 확보 (MCP).
    *   API 키 관리, 기본 파라미터 설정 등을 도구 수준에서 처리 가능.

### 9.3. API 호출 시 파라미터 최종 값 결정 (실험 기반 튜닝 필요)
*   **`temperature` (응답의 창의성/무작위성 조절)**:
    *   **비판적 분석가, 현실적 엔지니어**: **0.2 ~ 0.4** (일관되고 사실 기반의 예측 가능한 응답 유도)
    *   **창의적 마케터**: **0.7 ~ 0.9** (다양하고 창의적인 아이디어나 표현 유도)
    *   **오케스트레이터 (요약/판단 시)**: **0.3 ~ 0.5** (일관되고 정확한 요약이나 판단 유도)
    *   *이 값들은 초기 제안이며, 실제 테스트를 통해 각 페르소나의 역할에 가장 적합한 값을 찾아야 합니다.*
*   **`maxOutputTokens` (최대 생성 토큰 수)**:
    *   **각 페르소나의 일반적인 답변**: **256 ~ 768 토큰** 사이에서 조절. 답변이 너무 짧아 정보가 부족하거나, 너무 길어 사용자가 읽기 부담스럽지 않도록 균형을 맞춥니다. 각 페르소나의 역할과 예상 답변 길이를 고려하여 개별 설정 가능.
    *   **오케스트레이터의 최종 요약 보고서**: **512 ~ 1024 토큰** 또는 그 이상으로 설정하여 충분히 상세한 요약이 가능하도록 합니다.
    *   *Gemini 모델은 긴 컨텍스트를 잘 처리하므로 입력은 길어도 괜찮지만, 출력 토큰은 비용과 사용자 경험을 고려하여 적절히 제한합니다.*
*   **`topK`, `topP` (토큰 샘플링 다양성 조절)**:
    *   MVP 단계에서는 `temperature` 값 조절만으로도 충분한 제어가 가능할 수 있습니다. 필요에 따라 `topP` (예: 0.9 ~ 0.95)를 함께 사용하여 응답의 일관성과 다양성 사이의 균형을 맞출 수 있습니다. `topK`는 일반적으로 덜 사용됩니다.
    *   *초기에는 기본값을 사용하거나, `temperature`와 상호작용을 보며 미세 조정합니다.*
*   **`system_instruction` 또는 유사 기능 활용 (Gemini API)**:
    *   Gemini API가 모델의 전반적인 행동이나 역할을 지시하는 시스템 레벨의 프롬프트를 지원한다면, 각 페르소나의 핵심적인 역할, 말투, 목표 등을 여기에 명시합니다. (4.1~4.3에서 정의한 페르소나별 시스템 프롬프트 내용을 여기에 적용)
    *   이는 사용자 프롬프트(아이디어, 이전 대화 내용 등)와 별개로 LLM에게 페르소나의 정체성을 강력하게 주입하는 역할을 합니다.
*   **반복적인 테스트와 평가를 통한 최적화**: 위에 제시된 값들은 시작점일 뿐이며, 실제 다양한 아이디어와 대화 시나리오를 통해 각 파라미터가 응답 품질에 미치는 영향을 관찰하고, 각 페르소나가 의도한 대로 작동하도록 지속적으로 튜닝해야 합니다.

### 9.4. 비용 관리 및 모니터링 전략
*   **Google Cloud Console 활용**: Gemini API 사용량, 호출 횟수, 발생 비용 등을 Google Cloud Console의 Billing 및 API & Services 대시보드를 통해 주기적으로 **반드시 모니터링**합니다.
*   **예산 알림 설정**: GCP에서 예산을 설정하고, 특정 사용량 임계값 도달 시 이메일 등으로 알림을 받도록 설정하여 예상치 못한 과도한 비용 발생을 사전에 방지합니다.
*   **토큰 효율성 극대화**:
    *   **프롬프트 최적화**: 시스템 프롬프트와 사용자 프롬프트를 간결하고 명확하게 작성하여 불필요한 토큰 소모를 줄입니다. 반복적이거나 중복되는 정보는 최소화합니다.
    *   **컨텍스트 윈도우 활용**: Gemini Flash 모델의 긴 컨텍스트 윈도우를 효과적으로 활용하되, 매번 전체 히스토리를 전달하기보다는 필요한 만큼의 맥락(예: 최근 몇 턴의 대화, 또는 요약된 이전 대화)을 전달하여 입력 토큰을 관리합니다. (ADK의 메모리 기능과 연계)
    *   **출력 토큰 제어**: `maxOutputTokens`를 적절히 설정하여 불필요하게 긴 응답 생성을 방지합니다.
*   **개발/테스트 단계에서의 비용 절감**:
    *   가능하다면 더 저렴하거나 응답 속도가 빠른 모델(만약 있다면) 또는 샘플링된 데이터로 초기 개발 및 테스트를 진행합니다.
    *   Google Cloud에서 제공하는 무료 티어, 프로모션 크레딧, 또는 연구/개발용 지원 프로그램을 적극 활용합니다.
*   **로깅**: 각 LLM 호출 시 사용된 입력 토큰 수와 출력 토큰 수를 로깅하여 비용 분석 및 최적화에 활용합니다.

### 9.5. 프롬프트 엔지니어링 및 관리
*   **시스템 프롬프트의 중요성**: 각 페르소나의 역할, 목표, 말투, 전문 분야, 행동 지침 등을 상세하고 명확하게 기술한 시스템 프롬프트가 응답 품질에 가장 큰 영향을 미칩니다. (4.1~4.3에서 정의한 내용을 기반으로 작성)
*   **사용자 프롬프트 구성**: 오케스트레이터가 각 페르소나에게 전달할 사용자 프롬프트는 [사용자의 초기 아이디어 + 이전 대화의 맥락 정보 + 현재 페르소나에게 던지는 구체적인 질문/지시사항]으로 구성됩니다.
*   **반복적인 개선 (Iterative Refinement)**: 초기 프롬프트로 만족스러운 결과가 나오지 않을 수 있습니다. 다양한 아이디어와 상황에 대해 테스트하고, LLM의 응답을 분석하며 프롬프트를 지속적으로 수정하고 개선하는 과정이 필수적입니다.
*   **프롬프트 버전 관리**: 효과적인 프롬프트 조합을 찾으면, 이를 버전 관리 시스템(예: Git)을 통해 관리하거나, 데이터베이스에 프롬프트 템플릿 형태로 저장하여 쉽게 불러와 사용할 수 있도록 합니다.


10. Google ADK (Agent Development Kit) 활용 관련 상세 전략 (MVP 추천) - 수정본
10.1. Google ADK 설치 및 개발 환경 구축 절차 확정 (필수 선행 작업)
공식 문서 기반 설치: Google ADK 공식 문서(google.github.io/adk-docs/ 또는 최신 공식 출처)의 "Installation" 또는 "Getting Started" 가이드라인을 따라 정확하게 설치를 진행합니다.
확인 사항: 지원 Python 버전 (예: 3.9 이상), 필요한 시스템 의존성, pip install google-adk (제공된 ADK 문서 기준) 또는 공식 문서에서 안내하는 정확한 패키지명 및 설치 방법.
가상 환경 사용: Python 프로젝트의 표준적인 모범 사례에 따라, venv 또는 conda 등을 사용하여 프로젝트별 독립적인 가상 환경을 구성하고 그 안에 Google ADK를 설치합니다.
# 예시 (venv 사용)
python -m venv aidealab_env
source aidealab_env/bin/activate  # macOS/Linux
# aidealab_env\Scripts\activate  # Windows
pip install google-adk
# 기타 필요한 라이브러리 설치 (예: Streamlit, python-dotenv 등)
Use code with caution.
Bash
Google Cloud SDK (gcloud CLI) 설치 및 인증 (필요시):
Google ADK가 Gemini API 사용(특히 Vertex AI 엔드포인트 사용 시)이나 Vertex AI Agent Engine 등 Google Cloud 서비스와의 연동을 위해 gcloud CLI를 통한 인증 및 프로젝트 설정을 요구할 수 있습니다.
gcloud init 및 gcloud auth application-default login 등의 명령어를 통해 개발 환경을 설정합니다.
API 키 및 서비스 계정 관리: Gemini API 사용을 위한 API 키(예: GOOGLE_API_KEY) 또는 서비스 계정 키(JSON 파일)를 안전하게 관리하고, Google ADK가 이를 참조할 수 있도록 환경 변수(.env 파일과 python-dotenv 라이브러리 사용 권장) 또는 ADK가 지원하는 설정 파일에 등록하는 방법을 공식 문서에서 확인합니다.
기본 "Hello World" 에이전트 실행: ADK 설치 후, 공식 문서에서 제공하는 가장 간단한 형태의 LlmAgent 또는 워크플로우 예제를 실행해보는 튜토리얼을 따라 하여 개발 환경이 올바르게 설정되었는지 확인합니다.
10.2. ADK 내부 에이전트 간 데이터 구조 및 session.state 활용 정의
핵심 원칙: "AIdea Lab" 내 에이전트 간의 정보 공유 및 상태 관리는 주로 ADK의 session.state 메커니즘을 활용합니다. 이는 Google의 개방형 A2A 프로토콜과는 구분되는 ADK 내부의 효율적인 데이터 공유 방식입니다.
session.state에 저장될 주요 정보 스키마 (예상):
session_id (str): 현재 워크숍 세션을 식별하는 고유 ID (오케스트레이터가 관리 또는 ADK가 자동 생성 가능성 확인).
initial_idea (str): 사용자가 입력한 원본 아이디어.
dialogue_history (List[Dict]): 턴 기반 대화 기록. 각 딕셔너리는 다음을 포함할 수 있습니다:
turn_number (int)
speaker_agent_name (str): 발언한 LlmAgent의 name (예: "CriticPersona", "MarketerPersona") 또는 "user", "orchestrator".
message_content (str): 해당 턴의 발언 내용.
timestamp (datetime)
current_round (int): 현재 진행 중인 워크숍 라운드 번호.
persona_responses (Dict[str, str]): 각 페르소나 LlmAgent의 output_key를 통해 저장된 개별 응답들 (예: {"critic_response": "...", "marketer_response": "..."}).
기타 워크숍 진행에 필요한 임시 상태 변수.
데이터 전달 방식:
LlmAgent의 instruction 내에서 {state.variable_name} 구문을 사용하여 session.state의 값을 동적으로 참조합니다. (예: {state.initial_idea}, {state.persona_responses.critic_response})
LlmAgent의 output_key를 설정하여 해당 에이전트의 최종 응답 텍스트를 session.state[output_key]에 자동으로 저장합니다.
확장성: session.state에 저장되는 정보는 필요에 따라 유연하게 추가 및 수정될 수 있습니다.
10.3. 상태 관리(메모리) 메커니즘 구체적 사용법 (ADK session.state 활용)
ADK session.state 활용: Google ADK가 제공하는 session.state (또는 유사한 컨텍스트 공유 메커니즘)를 에이전트의 상태(대화 히스토리, 세션 정보 등) 관리의 핵심 수단으로 사용합니다.
오케스트레이터 에이전트 (SequentialAgent)의 역할:
워크숍 시작 시 session.state 초기화 (예: initial_idea 설정, dialogue_history 빈 리스트로 생성).
하위 LlmAgent(페르소나)들의 실행을 통해 session.state가 업데이트되는 것을 관리.
필요시 session.state의 정보를 바탕으로 다음 행동 결정 (MVP에서는 주로 순차 진행).
페르소나 에이전트 (LlmAgent)의 역할:
instruction을 통해 session.state의 정보(예: 이전 페르소나의 응답, 전체 대화 요약 등)를 입력 컨텍스트로 활용.
자신의 분석/제안 결과를 output_key를 통해 session.state에 기록.
상태 저장 및 로드 (DB 연동):
MVP에서는 세션 진행 중 session.state를 인메모리 상태로 유지하는 것을 목표로 합니다.
워크숍 종료 시 또는 중요한 시점에, session.state의 dialogue_history, persona_responses, 최종 요약 등을 **Database Access Tool (BaseTool 상속)**을 통해 데이터베이스에 저장하는 것을 고려합니다. (이를 통해 나중에 세션 이어가기 또는 분석 기능 구현 가능)
긴 대화 처리 (MVP 이후 고려):
매우 긴 대화의 경우, 전체 dialogue_history를 모든 LlmAgent의 instruction에 포함시키는 것은 토큰 제한 문제가 발생할 수 있습니다.
이 경우, 오케스트레이터(또는 별도의 요약 LlmAgent)가 주기적으로 dialogue_history를 요약하여 session.state['dialogue_summary']와 같이 저장하고, 페르소나들은 이 요약본을 참조하도록 하는 로직을 구현할 수 있습니다. ADK가 메모리 요약 관련 유틸리티나 Planner 기능을 제공하는지 확인합니다.
10.4. 도구(Tool) 정의 및 등록 방식 (ADK BaseTool 활용)
핵심 원칙: LlmAgent가 LLM 외의 외부 기능(데이터베이스 접근, 외부 API 호출, 복잡한 계산 등)을 수행해야 할 때 ADK의 '도구(Tool)' 메커니즘을 사용합니다. 도구는 google.adk.BaseTool을 상속받아 구현합니다.
LlmAgent의 LLM 사용: LlmAgent는 model 매개변수를 통해 지정된 LLM을 내부적으로 직접 활용하며, 이는 '도구 사용'과는 구분됩니다. LlmAgent의 핵심 기능이 LLM과의 상호작용입니다.
데이터베이스 접근 도구 (Database Access Tool) 정의:
BaseTool을 상속하는 파이썬 클래스로 구현.
메서드 예시: save_session_data(session_data: dict), load_session_data(session_id: str) -> dict, append_to_dialogue_history(session_id: str, turn_data: dict).
내부적으로 SQLite (MVP) 또는 다른 DB 드라이버를 사용하여 DB와 통신.
외부 데이터 API 도구 (External Data API Tool - 향후 확장 시) 정의:
BaseTool을 상속하며, 특정 외부 API(예: 시장 조사 API, 특허 검색 API) 호출 로직을 캡슐화.
도구 등록 및 에이전트 할당:
구현된 도구 클래스의 인스턴스를 생성하여, 해당 도구가 필요한 LlmAgent(예: 오케스트레이터가 DB 저장을 위해, 또는 특정 페르소나가 외부 데이터 조회를 위해)의 tools 리스트 매개변수에 전달합니다.
LlmAgent의 instruction에는 해당 도구를 언제 어떻게 사용해야 하는지에 대한 지침이 포함될 수 있습니다.
MCP 철학 준수: 각 BaseTool 구현체는 특정 외부 기능에 대한 명확하고 표준화된 인터페이스(메서드 시그니처, 입출력 데이터 구조)를 제공함으로써, LlmAgent가 도구의 내부 구현을 알 필요 없이 일관된 방식으로 외부 컨텍스트를 활용하도록 합니다.
10.5. Google ADK 기반 테스트 및 평가 도구 활용 계획 (MVP 이후 고려)
공식 문서 확인: Google ADK가 에이전트 테스트, 평가, 디버깅을 위한 내장 도구나 프레임워크(예: 테스트용 UI, 시나리오 실행기, 평가 지표 계산 유틸리티)를 제공하는지 확인합니다.
테스트 케이스 정의:
다양한 아이디어 입력에 대해 각 페르소나 LlmAgent가 instruction에 정의된 역할에 맞는 응답을 생성하는지 (output_key를 통해 session.state에 올바르게 저장되는지 확인).
오케스트레이터(SequentialAgent)가 페르소나 LlmAgent들을 정의된 순서대로 올바르게 실행하고, session.state가 의도대로 업데이트되는지.
"다음 단계 제안" 로직이 올바르게 작동하는지.
도구(BaseTool 구현체) 호출이 정상적으로 이루어지고, 예외 상황(예: DB 연결 실패, API 응답 오류)에 대한 처리가 적절한지.
LLM 응답 생성 실패 또는 예상치 못한 형식의 응답에 대한 에이전트의 대응 방안.
평가 지표 (정성적/정량적):
응답의 관련성, 일관성, 유창성, 유용성, 페르소나 역할 충실도 등 (정성적 평가).
작업 완료율, 특정 키워드 포함 여부, 응답 길이, LLM 토큰 사용량 등 (정량적 평가).
자동화된 테스트: 가능하다면 일부 핵심 기능(예: 특정 입력에 대한 특정 페르소나의 응답 패턴, 도구 호출 결과)에 대한 테스트 케이스는 자동화하여 회귀 테스트에 활용합니다.
MVP 단계: 초기에는 adk web 또는 adk run을 통한 수동 실행 테스트와 Python logging 모듈을 활용한 로그 분석 중심으로 진행하고, 점차 ADK의 평가 도구나 테스트 프레임워크 도입을 고려합니다.


# 11. 사용자 인터페이스 (UI) 설계 (MVP 추천: Streamlit 또는 Gradio 활용) - 수정본

## 11.1. UI 목표
*   사용자가 "AIdea Lab"의 핵심 기능을 쉽고 직관적으로 사용할 수 있도록 지원한다.
*   아이디어 입력, 워크숍 진행 상황 확인, 페르소나 의견 열람, 다음 단계 선택 등의 주요 상호작용을 원활하게 제공한다.
*   MVP 단계에서는 복잡한 디자인이나 기능보다는 핵심적인 사용성에 초점을 맞춘다.

## 11.2. 주요 화면 구성 및 기능 (Streamlit/Gradio 기반 프로토타입 예시)

### 11.2.1. 시작 화면 (Home/Welcome Screen)
*   **구성 요소**:
    *   프로젝트 로고 또는 이름 ("AIdea Lab")
    *   간단한 서비스 소개 및 사용 방법 안내
    *   아이디어 입력을 위한 텍스트 입력 영역 (큰 텍스트 박스)
    *   워크숍 시작 버튼
    *   (선택적) 이전 세션 불러오기 기능 (MVP 이후 고려)
*   **기능**:
    *   사용자가 아이디어를 입력하고 워크숍을 시작할 수 있도록 한다.
*   **UX 고려사항**:
    *   사용자가 서비스를 처음 접했을 때 무엇을 해야 하는지 명확하게 인지할 수 있도록 간결하고 명확한 안내를 제공한다.
    *   입력 영역을 충분히 크게 하여 아이디어를 편하게 작성할 수 있도록 한다.

### 11.2.2. 워크숍 진행 화면 (Workshop/Chat Screen)
*   **구성 요소**:
    *   **대화창 영역**:
        *   사용자가 입력한 초기 아이디어 표시.
        *   각 AI 페르소나의 아이콘/이름과 함께 해당 페르소나가 생성한 의견(텍스트)을 시간 순서대로 표시 (채팅 UI와 유사한 형태, 새로운 메시지 등장 시 부드러운 애니메이션 효과 고려).
        *   오케스트레이터 에이전트의 안내 메시지(예: "이제 [페르소나 이름]의 의견을 생성 중입니다...", "모든 페르소나의 분석이 완료되었습니다. 다음 단계를 선택해주세요.") 표시.
        *   스크롤 기능으로 이전 대화 내용 확인 가능.
    *   **진행 상태 표시 영역** (상단 또는 사이드바):
        *   현재 워크숍 진행 단계 (예: "아이디어 분석 중: 창의적 마케터", "응답 대기 중: 비판적 분석가", "최종 요약 준비 중").
        *   현재 라운드 번호 (해당 기능이 있다면).
        *   (선택적) 예상 남은 시간 또는 진행률 표시 (구현 난이도 고려).
    *   **사용자 액션 영역** (라운드 종료 시 또는 필요시 활성화):
        *   "다음 단계" 옵션 선택 버튼들 (예: "최종 요약 보기", "아이디어 수정 후 재시작").
        *   (MVP 초기 또는 사용자 선택에 따라) "다음 의견 보기" 또는 "워크숍 계속 진행" 버튼 (페르소나 발언을 하나씩 넘기면서 볼 경우).
*   **기능**:
    *   워크숍의 전체 대화 흐름을 실시간 또는 단계별로 보여준다.
    *   사용자가 각 페르소나의 의견을 명확히 구분하여 읽을 수 있도록 한다.
    *   라운드 종료 후 사용자가 다음 행동을 선택할 수 있도록 한다.
*   **UX 고려사항**:
    *   **가독성**: 폰트 크기, 줄 간격, 색상 대비 등을 고려하여 긴 텍스트도 편안하게 읽을 수 있도록 한다.
    *   **정보 구분**: 각 페르소나의 발언, 오케스트레이터의 안내, 사용자의 입력(초기 아이디어)을 시각적으로 명확히 구분한다. (예: 말풍선 색상, 아이콘, 발신자 이름 명시)
    *   **진행 피드백 강화**:
        *   **응답 생성 중**: "AI [페르소나 이름]이(가) 아이디어를 분석하고 답변을 생성 중입니다... 잠시만 기다려주세요." 와 같이 구체적인 메시지와 함께 로딩 인디케이터(Streamlit/Gradio의 스피너, 진행 바 등)를 표시하여 사용자의 기다림을 관리한다.
        *   **응답 완료 및 표시**: 새로운 페르소나의 의견이 준비되면, 시각적인 알림(예: 새로운 메시지 알림 뱃지, 부드러운 스크롤 이동)과 함께 해당 의견으로 포커스를 이동시켜 사용자가 새로운 내용을 쉽게 인지하도록 한다.
        *   **단계 전환**: 다음 페르소나로 넘어가거나 특정 작업이 완료될 때 명확한 안내 메시지를 제공한다 (예: "창의적 마케터의 분석이 완료되었습니다. 이제 비판적 분석가의 의견을 생성합니다.").
    *   **오류 상황 UI/UX**:
        *   **응답 지연/타임아웃**: "응답을 가져오는 데 예상보다 시간이 오래 걸리고 있습니다. 잠시 후 자동으로 재시도하거나, 문제가 지속되면 관리자에게 문의해주세요." 와 같은 안내 메시지와 함께, (가능하다면) 재시도 버튼 또는 문제 보고 옵션 제공.
        *   **LLM API 오류/시스템 오류**: "죄송합니다. 현재 서비스에 일시적인 오류가 발생하여 요청을 처리할 수 없습니다. 잠시 후 다시 시도해주시거나, 문제가 지속되면 오류 코드 [오류 코드]와 함께 문의해주십시오." 와 같이 사용자에게 상황을 알리고, 기술적이지 않은 용어로 설명한다.
        *   **입력값 오류 (UI 단에서 처리 가능 시)**: 아이디어 입력이 너무 짧거나 부적절한 내용 포함 시, "유효한 아이디어를 입력해주세요." 와 같이 즉각적인 피드백 제공.

### 11.2.3. 최종 요약 보고서 화면 (Summary Report Screen)
*   **구성 요소**:
    *   워크숍에서 논의된 아이디어 제목 또는 요약.
    *   오케스트레이터 에이전트(또는 요약 전문 `LlmAgent`)가 생성한 최종 요약 보고서 텍스트:
        *   주요 장점
        *   주요 단점/리스크
        *   핵심 피드백 (페르소나별 또는 종합)
        *   실행 가능한 다음 단계 제안
    *   (선택적) 워크숍 다시 시작 버튼, 요약 내용 복사/저장 버튼, PDF 다운로드 버튼 (MVP 이후).
*   **기능**:
    *   사용자가 워크숍의 결과를 한눈에 파악하고 활용할 수 있도록 한다.
*   **UX 고려사항**:
    *   **정보 구조화**: 요약 보고서의 각 섹션(장점, 단점 등)을 명확한 제목과 함께 구조화하여 보여준다. 가독성을 위해 적절한 목록이나 강조 표시 사용.
    *   **활용성**: 사용자가 요약 내용을 쉽게 복사하거나 다른 곳에 활용할 수 있도록 지원한다. (예: "클립보드로 복사" 버튼)

## 11.3. 사용자 경험(UX) 흐름 (User Flow)
1.  **시작**: 사용자가 AIdea Lab 서비스에 접속한다.
2.  **아이디어 입력**: 시작 화면에서 자신의 아이디어를 텍스트로 입력하고 "워크숍 시작" 버튼을 클릭한다. (오류 발생 시, 5.2.2의 오류 상황 UI/UX에 따라 안내)
3.  **워크숍 진행**:
    *   워크숍 진행 화면으로 전환된다. 로딩 인디케이터와 함께 "워크숍을 준비 중입니다..." 메시지 표시.
    *   오케스트레이터의 안내(예: "[창의적 마케터]가 아이디어를 분석 중입니다...")와 함께 첫 번째 페르소나의 의견이 로딩 후 표시된다.
    *   사용자는 (MVP에서는 "다음 의견 보기" 버튼 클릭 또는 자동으로 다음 페르소나 의견 로딩 안내 후) 다음 페르소나의 의견을 순차적으로 확인한다. 각 페르소나 의견 로딩 시 진행 피드백 제공. 이 과정에서 이전 페르소나의 의견도 함께 볼 수 있다.
    *   모든 페르소나(MVP에서는 3명)의 의견 제시가 완료되면, 오케스트레이터가 이를 알린다.
4.  **다음 단계 선택**:
    *   오케스트레이터가 "다음 단계" 옵션(예: "최종 요약 보기", "아이디어 수정 후 재시작")을 버튼 형태로 제시한다.
    *   사용자가 원하는 옵션을 클릭한다.
5.  **결과 확인 또는 재시작**:
    *   **"최종 요약 보기" 선택 시**: 로딩 인디케이터(예: "최종 요약을 생성 중입니다...") 후 최종 요약 보고서 화면으로 전환되어 오케스트레이터가 생성한 요약 내용을 확인한다.
    *   **"아이디어 수정 후 재시작" 선택 시**: 아이디어를 수정 입력할 수 있는 화면(또는 시작 화면으로 돌아가 이전 아이디어가 채워진 상태)으로 전환되고, 새로운 워크숍이 시작된다.
6.  **(선택적) 세션 종료 및 데이터 저장**: 사용자가 워크숍을 완전히 종료하거나, 특정 시점(예: 최종 요약 생성 후)에 현재까지의 진행 내용이 데이터베이스에 저장될 수 있다.

## 11.4. UI 구현 도구 (MVP 추천)
*   **Streamlit**:
    *   **장점**: 순수 Python 코드로 매우 빠르게 웹 UI를 만들 수 있음. 데이터 시각화 및 상호작용 위젯이 풍부. Python 백엔드 로직(Google ADK 에이전트)과 직접 연동이 매우 용이. 1인 개발자가 UI와 백엔드를 동시에 관리하기에 좋음. `st.spinner()` 등으로 진행 피드백 구현 용이.
    *   **단점**: 디자인 커스터마이징에 한계가 있을 수 있음. 매우 복잡한 UI나 상태 관리는 어려울 수 있음.
*   **Gradio**:
    *   **장점**: 머신러닝 모델 데모용 UI를 만드는 데 특화되어 있으며, 몇 줄의 코드만으로도 인터랙티브한 UI를 쉽게 만들 수 있음. 채팅 인터페이스 구현에 유용한 컴포넌트(`gr.Chatbot`, `gr.Textbox`) 제공.
    *   **단점**: Streamlit보다 범용적인 웹 애플리케이션 구축에는 기능이 제한적일 수 있음.
*   **선택 가이드**: 두 도구 모두 MVP 단계에서는 훌륭한 선택입니다. 만약 좀 더 데이터 중심적이거나 다양한 위젯을 활용하고 싶다면 Streamlit을, 빠르고 간단한 채팅 인터페이스나 모델 데모 형태에 집중하고 싶다면 Gradio를 고려해볼 수 있습니다. 두 도구 모두 Python 개발자에게 매우 친숙하며, MVP 목표인 "핵심 사용성"에 집중하기에 적합합니다.

## 11.5. 디자인 고려사항 (MVP에서는 단순함과 명확성에 집중)
*   **일관성**: 전체 화면과 구성 요소에서 일관된 디자인 스타일(색상, 폰트, 레이아웃)을 유지한다.
*   **가독성**: 텍스트 내용을 읽기 쉽도록 충분한 폰트 크기, 명확한 색상 대비, 적절한 여백을 사용한다.
*   **직관성**: 사용자가 각 버튼이나 입력 필드의 기능을 쉽게 이해하고 다음 행동을 예측할 수 있도록 직관적으로 설계한다.
*   **피드백**: 사용자의 액션에 대한 시스템의 반응(로딩, 성공, 오류 등)을 명확하게 전달한다.
*   **반응성 (선택적)**: 다양한 화면 크기(데스크톱, 태블릿 등)에서도 기본적인 사용성을 유지하도록 고려할 수 있으나, MVP에서는 우선 데스크톱 환경에 최적화한다.