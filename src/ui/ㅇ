"""
AIdea Lab - 아이디어 분석 워크숍 UI

이 모듈은 Streamlit을 이용한 챗봇 인터페이스를 제공합니다.
사용자는 아이디어를 입력하고 AI 페르소나들의 분석 결과를 챗봇 형태로 볼 수 있습니다.
"""

import os
import sys
import asyncio
import streamlit as st
import time
from dotenv import load_dotenv
from google.adk.runners import Runner
from google.adk.sessions import InMemorySessionService
from google.genai import types

# 프로젝트 루트 디렉토리를 sys.path에 추가
sys.path.append(os.path.abspath(os.path.join(os.path.dirname(__file__), '../..')))
from src.orchestrator.main_orchestrator import AIdeaLabOrchestrator
from src.session_manager import SessionManager  # 새로 추가된 SessionManager import
from config.personas import PERSONA_CONFIGS, PersonaType, ORCHESTRATOR_CONFIG, PERSONA_SEQUENCE
from config.models import get_model_display_options, MODEL_CONFIGS, ModelType, DEFAULT_MODEL

# .env 파일에서 환경 변수 로드
load_dotenv()

# Streamlit 페이지 설정
st.set_page_config(
    page_title="AIdea Lab - 아이디어 분석 워크숍",
    page_icon="🧠",
    layout="centered"  # 챗봇 UI에 적합한 centered 레이아웃
)

# 앱 정보
APP_NAME = "AIdea Lab"
USER_ID = "streamlit_user"

# 세션 관리자 초기화
session_manager = SessionManager(APP_NAME, USER_ID)

# 시스템 안내 메시지 템플릿 정의
SYSTEM_MESSAGES = {
    "welcome": "**AIdea Lab에 오신 것을 환영합니다.** 당신의 아이디어를 입력하시면 AI 페르소나들이 다양한 관점에서 분석해드립니다.",
    "phase1_start": "**분석을 시작합니다.** 각 AI 페르소나가 순차적으로 의견을 제시할 예정입니다.",
    "marketer_intro": "**🔍 아이디어 마케팅 분석가의 의견:**",
    "critic_intro": "**⚠️ 비판적 분석가의 의견:**", 
    "engineer_intro": "**⚙️ 엔지니어의 의견:**",
    "summary_intro": "**📝 최종 요약 및 종합:**",
    "phase1_complete": "**분석이 완료되었습니다.** 더 깊이 알아보시려면 다음 단계로 진행해주세요.",
    "phase1_error": "**분석 중 오류가 발생했습니다.** 다시 시도해주세요."
}

# 페르소나 아바타 정의
persona_avatars = {
    "marketer": "💡",
    "critic": "🔍",
    "engineer": "⚙️",
    "summary_agent_phase1": "📝"
}

print(f"Initialized persona avatars: {persona_avatars}")

class ADKRunner:
    """Google ADK 에이전트 실행을 위한 래퍼 클래스"""
    
    def __init__(self, workflow):
        """초기화 함수"""
        self.workflow = workflow
    
    async def run(self):
        """에이전트 실행 및 이벤트 스트림 생성"""
        print("ADKRunner.run() called")
        # 여기서는 실제 ADK 이벤트를 시뮬레이션합니다
        # 실제 구현에서는 ADK 이벤트를 yield하는 코드로 대체됩니다
        await asyncio.sleep(0.5)  # 시뮬레이션 지연
        yield type('Event', (), {'agent_name': 'marketer_agent', 'is_final_response': lambda: True, 'payload': {'content': '마케터 응답'}})
        await asyncio.sleep(0.5)
        yield type('Event', (), {'agent_name': 'critic_agent', 'is_final_response': lambda: True, 'payload': {'content': '비평가 응답'}})
        await asyncio.sleep(0.5)
        yield type('Event', (), {'agent_name': 'engineer_agent', 'is_final_response': lambda: True, 'payload': {'content': '엔지니어 응답'}})
        await asyncio.sleep(0.5)
        yield type('Event', (), {'agent_name': 'summary_agent', 'is_final_response': lambda: True, 'payload': {'content': '요약 응답'}})
        await asyncio.sleep(0.5)
        yield type('Event', (), {'agent_name': 'phase1_workflow', 'is_final_response': lambda: True})

# 텍스트를 단어 단위로 스트리밍하는 함수
def stream_text(text):
    """
    텍스트를 단어 단위로 스트리밍하는 제너레이터 함수
    
    Args:
        text (str): 스트리밍할 텍스트
        
    Yields:
        str: 단어 단위로 스트리밍된 텍스트
    """
    words = text.split(' ')
    result = ""
    for word in words:
        result += word + " "
        time.sleep(0.05)  # 단어 사이에 약간의 지연 추가
        yield result

def run_phase1_analysis_and_update_ui():
    """
    아이디어 분석을 실행하고 UI를 업데이트합니다.
    이 함수는 st.session_state.current_idea가 설정되어 있어야 합니다.
    """
    try:
        # 로컬 오케스트레이터 인스턴스 생성
        orchestrator = AIdeaLabOrchestrator(model_name=st.session_state.selected_model)
        print(f"Created local orchestrator with model: {st.session_state.selected_model}")
        
        # 분석 상태 설정
        st.session_state.analysis_phase = "phase1_running"
        st.session_state.analysis_step = "starting"
        
        # 분석 시작 메시지 저장
        show_system_message("phase1_start")
        print("Phase 1 analysis started")
        
        # 사용자 정보 가져오기
        idea_text = st.session_state.current_idea
        user_goal = st.session_state.user_goal if hasattr(st.session_state, "user_goal") else None
        user_constraints = st.session_state.user_constraints if hasattr(st.session_state, "user_constraints") else None
        user_values = st.session_state.user_values if hasattr(st.session_state, "user_values") else None
        print(f"Analyzing idea: {idea_text}")
        print(f"User info - Goal: {user_goal}, Constraints: {user_constraints}, Values: {user_values}")
        
        # 새 세션 시작 - 반환값 올바르게 언패킹
        session_object, session_id_string = session_manager.start_new_idea_session(
            idea_text,
            user_goal=user_goal,
            user_constraints=user_constraints,
            user_values=user_values
        )
        
        # 디버깅용 로깅 - 세션 객체와 ID 확인
        print(f"Session object type: {type(session_object).__name__}")
        print(f"Session ID string type: {type(session_id_string).__name__}, value: {session_id_string}")
        
        st.session_state.adk_session_id = session_id_string  # 문자열 세션 ID만 저장
        print(f"Created new session with ID: {session_id_string}")
        
        # 워크플로우 에이전트 가져오기
        phase1_workflow_agent = orchestrator.get_phase1_workflow()
        print(f"Successfully retrieved phase1_workflow_agent using get_phase1_workflow()")
        
        # 러너 초기화
        try:
            runner = Runner(
                agent=phase1_workflow_agent,
                app_name=APP_NAME,
                session_service=session_manager.session_service
            )
            print(f"Successfully initialized Runner with agent, app_name={APP_NAME}, and session_service")
        except Exception as e:
            print(f"ERROR initializing Runner: {str(e)}")
            import traceback
            traceback.print_exc()
            st.session_state.analysis_phase = "phase1_error"
            st.session_state.analysis_step = "error"
            show_system_message("phase1_error")
            st.session_state.need_rerun = True
            return
        
        # 비동기 함수 _run_phase1_analysis 정의
        async def _run_phase1_analysis(runner, session_id_string, content, orchestrator, phase1_workflow_agent_name):
            print(f"DEBUG: _run_phase1_analysis - Starting with session_id: {session_id_string}, Workflow Agent Name: {phase1_workflow_agent_name}")
            
            try:
                output_keys_map = orchestrator.get_output_keys_phase1() # .items() 안해도 됨
                print(f"DEBUG: _run_phase1_analysis - Output keys map from orchestrator: {output_keys_map}")
                
                event_stream = runner.run_async(
                    user_id=USER_ID,
                    session_id=session_id_string,
                    new_message=content
                )
                
                workflow_completed_event_received = False
                all_responses_found_in_final_state = False # 최종 상태에서 모든 응답이 발견되었는지
                
                async for event in event_stream:
                    print(f"DEBUG: _run_phase1_analysis - Event Received: Type={type(event).__name__}, Details={str(event)[:500]}...") # 너무 긴 이벤트는 일부만 로깅
                    
                    agent_name = getattr(event, 'agent_name', None)
                    is_final = hasattr(event, 'is_final_response') and event.is_final_response()

                    if agent_name and is_final:
                        print(f"DEBUG: Final response detected for agent: {agent_name}")
                        if hasattr(event, 'actions') and hasattr(event.actions, 'state_delta') and event.actions.state_delta:
                            print(f"DEBUG: State delta for {agent_name}: {event.actions.state_delta}")
                        
                        # SequentialAgent 전체의 실행 완료 확인
                        if agent_name == phase1_workflow_agent_name:
                            print(f"DEBUG: _run_phase1_analysis - Workflow COMPLETED event for: {agent_name}")
                            workflow_completed_event_received = True
                            # 여기서 break 하기 전에 최종 상태를 확인하는 것이 중요
                            final_session = session_manager.get_session(session_id_string)
                            if final_session and hasattr(final_session, 'state'):
                                print("== FINAL SESSION STATE (within _run_phase1_analysis after workflow completion event) ==")
                                final_state = final_session.state
                                final_keys = sorted(final_state.keys())
                                print(f"Final session keys: {final_keys}")
                                
                                temp_responses_found = True # 이번 검증에서의 성공 여부
                                for persona_key, output_key_value in output_keys_map.items():
                                    if output_key_value in final_state:
                                        val = final_state.get(output_key_value)
                                        val_prev = str(val)[:50] + "..." if val and len(str(val)) > 50 else str(val)
                                        print(f"  Key '{output_key_value}' for '{persona_key}': FOUND, Value: {val_prev}")
                                        if not val or (isinstance(val, str) and len(str(val).strip()) < 10):
                                            print(f"  WARNING: Empty or very short value for '{output_key_value}'")
                                            temp_responses_found = False
                                    else:
                                        print(f"  Key '{output_key_value}' for '{persona_key}': MISSING in final state")
                                        temp_responses_found = False
                                all_responses_found_in_final_state = temp_responses_found # 최종 결과 업데이트
                                print("== END FINAL SESSION STATE (within _run_phase1_analysis) ==")
                            else:
                                print("ERROR: _run_phase1_analysis - Could not retrieve final session or session has no state after workflow completion event.")
                                all_responses_found_in_final_state = False
                            break # 워크플로우 완료 이벤트 수신 후 루프 종료
                
                print(f"DEBUG: _run_phase1_analysis - Event stream processing finished. Workflow completed event received: {workflow_completed_event_received}, All responses found in final state: {all_responses_found_in_final_state}")
                
                # SequentialAgent 완료 이벤트가 수신되었고, 그 상태에서 모든 응답이 발견된 경우에만 True 반환
                return workflow_completed_event_received and all_responses_found_in_final_state
                    
            except Exception as e:
                print(f"ERROR in _run_phase1_analysis: {str(e)}")
                import traceback
                traceback.print_exc()
                return False

        try:
            print("Starting analysis run...")
            print(f"Phase 1 workflow agent: {phase1_workflow_agent}")
            
            # 입력 컨텐츠 설정
            content = types.Content(
                role="user",
                parts=[types.Part(text=f"아이디어: {idea_text}\n목표: {user_goal}\n제약조건: {user_constraints}\n가치: {user_values}")]
            )
            
            print(f"Prepared content for runner.run() - Idea: {idea_text}")
            print(f"Content object: {content}")
            
            # 비동기 함수 _run_phase1_analysis 실행 (asyncio.run으로 동기적 실행 환경에서 호출)
            print("Starting _run_phase1_analysis with proper parameters...")
            analysis_success = asyncio.run(_run_phase1_analysis(
                runner, 
                session_id_string, 
                content, 
                orchestrator, 
                phase1_workflow_agent.name
            ))
            
            # 워크플로우 완료 후 최신 세션 상태에서 결과 추출
            if analysis_success:
                print("Retrieving results from session state...")
                current_session = session_manager.get_session(session_id_string)  # 문자열 세션 ID 사용
                if not current_session:
                    print("ERROR: Session not found after workflow completion")
                    analysis_success = False
                else:
                    # 세션 상태 덤프 (디버깅용)
                    print("== SESSION STATE DUMP ==")
                    state_keys = sorted(current_session.state.keys())
                    print(f"Session state keys after workflow: {state_keys}")
                    for key in state_keys:
                        value = current_session.state.get(key)
                        value_type = type(value).__name__
                        preview = str(value)[:100] + "..." if isinstance(value, str) and len(str(value)) > 100 else str(value)
                        print(f"SESSION STATE: KEY={key}, TYPE={value_type}, PREVIEW={preview}")
                    print("== END SESSION STATE DUMP ==")
                    
                    # 출력 키 가져오기
                    output_keys = orchestrator.get_output_keys_phase1()
                    print(f"Output keys from orchestrator: {output_keys}")
                    
                    # 출력 키 상세 검사
                    print("== OUTPUT KEYS DETAILED CHECK ==")
                    for persona_key, output_key in output_keys.items():
                        if output_key in current_session.state:
                            value = current_session.state.get(output_key)
                            print(f"OUTPUT KEY FOUND: {output_key} for {persona_key}, Value length: {len(str(value)) if value else 0}")
                            if not value or (isinstance(value, str) and len(value.strip()) < 10):
                                print(f"WARNING: Output key {output_key} has empty or very short value: '{value}'")
                        else:
                            print(f"MISSING OUTPUT KEY: {output_key} for {persona_key}")
                    print("== END OUTPUT KEYS DETAILED CHECK ==")
                    
                    # config/personas.py의 PERSONA_SEQUENCE 순서에 따른 페르소나 목록
                    # 마케터 -> 비판적 분석가 -> 엔지니어 -> 요약
                    personas = [
                        ("marketer", "marketer_intro", persona_avatars.get("marketer", "💡")),
                        ("critic", "critic_intro", persona_avatars.get("critic", "🔍")),
                        ("engineer", "engineer_intro", persona_avatars.get("engineer", "⚙️")),
                        ("summary_phase1", "summary_intro", persona_avatars.get("summary_agent_phase1", "📝"))
                    ]
                    
                    # 응답을 찾았는지 추적
                    responses_found = False
                    
                    # 간단하게 결과 추출 및 메시지 추가
                    for persona_key, intro_message, avatar in personas:
                        # 출력 키 확인
                        output_key = output_keys.get(persona_key)
                        if not output_key:
                            print(f"WARNING: No output key defined for {persona_key}")
                            continue
                            
                        # 세션 상태에서 응답 가져오기
                        if output_key in current_session.state:
                            response = current_session.state.get(output_key)
                            if response and isinstance(response, str) and len(response) > 50:  # 유효한 응답인지 확인
                                # 시스템 소개 메시지 추가
                                show_system_message(intro_message)
                                # 실제 페르소나 응답 추가
                                add_message("assistant", process_text_for_display(response), avatar=avatar)
                                print(f"Added {persona_key} response with key {output_key} from session state")
                                responses_found = True
                            else:
                                print(f"WARNING: Empty or invalid response for {persona_key} with key {output_key}: {response}")
                        else:
                            print(f"WARNING: Output key '{output_key}' not found in session state")
                            
                            # 추가 검색: 키 이름이 일부 포함된 경우 찾기 시도
                            for key in state_keys:
                                if persona_key.lower() in key.lower():
                                    value = current_session.state.get(key)
                                    if isinstance(value, str) and len(value) > 50:
                                        print(f"Found potential match for {persona_key}: {key}")
                                        show_system_message(intro_message)
                                        add_message("assistant", process_text_for_display(value), avatar=avatar)
                                        print(f"Added {persona_key} response with alternative key {key}")
                                        responses_found = True
                                        break
                    
                    # 응답을 찾지 못한 경우
                    if not responses_found:
                        print("WARNING: No responses found in session state")
                        show_system_message("phase1_error")
                        analysis_success = False
                    else:
                        # 분석 완료 메시지 추가
                        show_system_message("phase1_complete")
                    
                    # st.session_state.messages 내용 디버깅 로그
                    print("== MESSAGES STATE DUMP ==")
                    print(f"Messages count: {len(st.session_state.messages)}")
                    for i, msg in enumerate(st.session_state.messages):
                        msg_role = msg.get("role", "unknown")
                        msg_avatar = msg.get("avatar", "none")
                        msg_content_preview = str(msg.get("content", ""))[:50] + "..." if len(str(msg.get("content", ""))) > 50 else str(msg.get("content", ""))
                        print(f"Message #{i}: Role={msg_role}, Avatar={msg_avatar}, Content preview: {msg_content_preview}")
                    print("== END MESSAGES STATE DUMP ==")
            
            # 분석이 실패한 경우
            if not analysis_success:
                print("Analysis was not successful")
                # 오류 상태 설정
                st.session_state.analysis_phase = "phase1_error"
                st.session_state.analysis_step = "error"
                show_system_message("phase1_error")
            else:
                # 성공한 경우 최종 상태 설정
                st.session_state.analysis_phase = "phase1_complete"
                st.session_state.analysis_step = "complete"
            
            # UI 갱신 준비
            st.session_state.need_rerun = True
            print("Analysis completed. UI will be updated on next rerun.")
            
            # 종료 시 상태 요약 로그
            print(f"=== ANALYSIS RESULT SUMMARY ===")
            print(f"Analysis status: {'SUCCESS' if analysis_success else 'FAILED'}")
            print(f"Messages count: {len(st.session_state.messages)}")
            print(f"Analysis phase: {st.session_state.analysis_phase}")
            print(f"Need rerun: {st.session_state.need_rerun}")
            print(f"=============================")
            
        except Exception as e:
            print(f"Error during analysis execution: {str(e)}")
            import traceback
            traceback.print_exc()
            
            # 오류 상태 설정
            st.session_state.analysis_phase = "phase1_error"
            st.session_state.analysis_step = "error"
            show_system_message("phase1_error")
            st.session_state.need_rerun = True
            
    except Exception as e:
        print(f"Error during orchestrator or runner setup: {str(e)}")
        import traceback
        traceback.print_exc()
        
        # 오류 상태 설정
        st.session_state.analysis_phase = "phase1_error"
        st.session_state.analysis_step = "error"
        show_system_message("phase1_error")
        st.session_state.need_rerun = True

def initialize_session_state():
    """세션 상태 초기화"""
    if 'session_counter' not in st.session_state:
        st.session_state.session_counter = 0
    
    # 선택된 모델 세션 상태 초기화
    if 'selected_model' not in st.session_state:
        st.session_state.selected_model = DEFAULT_MODEL.value
    
    # 채팅 관련 세션 상태 초기화
    if 'messages' not in st.session_state:
        st.session_state.messages = [] # {"role": "user/assistant/system", "content": "...", "avatar": "🧑‍💻/🧠/⚙️"}
        # 초기 환영 메시지 추가 (메시지 초기화 시 한 번만 추가)
        try:
            welcome_message = SYSTEM_MESSAGES.get("welcome", "AIdea Lab에 오신 것을 환영합니다.")
            add_message("assistant", welcome_message, avatar="⚙️")
        except Exception as e:
            print(f"환영 메시지 추가 중 오류 발생: {str(e)}")
            # 백업 환영 메시지 추가
            add_message("assistant", "AIdea Lab에 오신 것을 환영합니다.", avatar="⚙️")
    
    # 아이디어 및 분석 상태
    if 'current_idea' not in st.session_state: # 사용자가 현재 입력한 아이디어 (분석 전)
        st.session_state.current_idea = ""
    if 'analyzed_idea' not in st.session_state: # 분석이 완료된 아이디어 (중복 실행 방지용)
        st.session_state.analyzed_idea = ""
    if 'analysis_phase' not in st.session_state: # "idle", "phase1_running", "phase1_complete", "phase2_running", ...
        st.session_state.analysis_phase = "idle"
    if 'phase1_step' not in st.session_state: # 1단계 분석의 세부 상태 ("awaiting_idea", "idea_submitted", "analysis_started", ...)
        st.session_state.phase1_step = "awaiting_idea"
    if 'adk_session_id' not in st.session_state:
        st.session_state.adk_session_id = None
    if 'user_goal' not in st.session_state: # 사용자 추가 정보
        st.session_state.user_goal = ""
    if 'user_constraints' not in st.session_state: # 사용자 제약 조건
        st.session_state.user_constraints = ""
    if 'user_values' not in st.session_state: # 사용자 중요 가치
        st.session_state.user_values = ""
    if 'show_additional_info' not in st.session_state: # 추가 정보 입력 필드 표시 여부
        st.session_state.show_additional_info = False
    if 'expander_state' not in st.session_state: # expander 오픈 상태 유지
        st.session_state.expander_state = True
    if 'need_rerun' not in st.session_state: # rerun 필요 여부 플래그
        st.session_state.need_rerun = False

def update_setting(key, value):
    """
    설정을 업데이트하는 함수
    
    Args:
        key (str): 업데이트할 설정 키
        value: 설정할 값
    """
    # 설정 업데이트
    setattr(st.session_state, key, value)
    # UI 업데이트 플래그 설정
    st.session_state.need_rerun = True

def restart_session(keep_messages=False):
    """
    애플리케이션 세션을 재시작합니다.
    
    Args:
        keep_messages (bool): 메시지 히스토리 유지 여부
    """
    print("Restarting session...")
    
    # 메시지 저장 (keep_messages가 True일 경우)
    messages_backup = None
    if keep_messages and 'messages' in st.session_state:
        messages_backup = st.session_state.messages.copy()
    
    # 분석 관련 상태 초기화
    st.session_state.current_idea = ""
    st.session_state.analyzed_idea = ""
    st.session_state.analysis_phase = "idle"
    st.session_state.phase1_step = "awaiting_idea"
    st.session_state.adk_session_id = None
    
    # 필요한 경우 메시지 복원
    if keep_messages and messages_backup:
        st.session_state.messages = messages_backup
    elif not keep_messages:
        # 메시지를 유지하지 않는 경우 메시지 초기화
        st.session_state.messages = []
        # 환영 메시지 다시 추가
        try:
            welcome_message = SYSTEM_MESSAGES.get("welcome", "AIdea Lab에 오신 것을 환영합니다.")
            add_message("assistant", welcome_message, avatar="⚙️")
        except Exception as e:
            print(f"환영 메시지 추가 중 오류 발생: {str(e)}")
            add_message("assistant", "AIdea Lab에 오신 것을 환영합니다.", avatar="⚙️")
    
    print("Session restart completed.")

def main():
    """
    메인 UI 로직
    """
    # 세션 상태 초기화
    initialize_session_state()
    
    # 상단 헤더 설정
    st.title("AIdea Lab - 아이디어 검증 도구")
    st.markdown("당신의 아이디어를 AI가 다양한 관점에서 분석해드립니다!")
    
    # AI 모델 선택 UI
    model_col1, model_col2 = st.columns([3, 1])
    with model_col1:
        try:
            model_options = [model.value for model in ModelType]
            default_index = model_options.index(st.session_state.selected_model) if st.session_state.selected_model in model_options else 0
            selected_model = st.selectbox(
                "AI 모델 선택",
                options=model_options,
                index=default_index,
                key="model_selector"
            )
        except Exception as e:
            print(f"모델 선택 UI 생성 중 오류 발생: {str(e)}")
            selected_model = DEFAULT_MODEL.value
            st.selectbox(
                "AI 모델 선택",
                options=[DEFAULT_MODEL.value],
                index=0,
                key="model_selector"
            )
    with model_col2:
        if st.button("모델 적용", key="apply_model"):
            # 선택된 모델 저장
            st.session_state.selected_model = selected_model
            print(f"Model changed to: {selected_model}")
            
            # 세션 재시작 (오케스트레이터는 run_phase1_analysis_and_update_ui에서 생성됨)
            restart_session()
            st.session_state.need_rerun = True
    
    # 채팅 메시지 표시 (단일 루프로 모든 메시지 렌더링)
    messages_container = st.container()
    with messages_container:
        # 세션 상태에 저장된 메시지들 표시
        if st.session_state.messages:
            for message in st.session_state.messages:
                role = message.get("role", "")
                content = message.get("content", "")
                avatar = message.get("avatar", None)
                print(f"Rendering message - Role: {role}, Avatar: {avatar}, Content preview: {content[:50]}...")
                
                if role == "user":
                    st.chat_message(role, avatar="🧑‍💻").write(content)
                elif role == "assistant":
                    st.chat_message(role, avatar=avatar).write(content)
                elif role == "system":
                    st.info(content)
    
    # 입력 UI 부분
    input_container = st.container()
    with input_container:
        # 아이디어 상태에 따른 UI 표시
        if st.session_state.analysis_phase == "idle":
            # 추가 정보 입력 버튼
            if st.button("추가 정보 입력", key="toggle_additional_info"):
                st.session_state.show_additional_info = not st.session_state.show_additional_info
                st.session_state.expander_state = True  # 펼침 상태로 초기화
                st.session_state.need_rerun = True
            
            # 추가 정보 입력 폼 표시 (토글 상태에 따라)
            if st.session_state.show_additional_info:
                with st.expander("추가 정보", expanded=st.session_state.expander_state):
                    st.text_area("목표 또는 문제 정의", key="user_goal", 
                              placeholder="이 아이디어로 해결하려는 목표나 문제는 무엇인가요?",
                              on_change=lambda: update_setting("expander_state", True))
                    st.text_area("제약 조건", key="user_constraints", 
                              placeholder="고려해야 할 제약 조건이 있나요? (예산, 시간, 기술적 제약 등)",
                              on_change=lambda: update_setting("expander_state", True))
                    st.text_area("중요 가치", key="user_values", 
                              placeholder="이 아이디어에서 중요시하는 가치는 무엇인가요? (효율성, 창의성, 사용성 등)",
                              on_change=lambda: update_setting("expander_state", True))
            
            # 아이디어 입력창
            user_input = st.chat_input("아이디어를 입력하세요")
            if user_input:
                # 사용자 메시지 추가
                add_message("user", user_input)
                # 현재 아이디어 저장
                st.session_state.current_idea = user_input
                # 분석 준비 상태로 변경
                st.session_state.analysis_phase = "phase1_pending_start"
                st.session_state.need_rerun = True
        
        # 분석 시작 대기 상태
        elif st.session_state.analysis_phase == "phase1_pending_start":
            # 분석 실행 스피너 표시
            with st.spinner("AI 페르소나가 아이디어를 분석 중입니다..."):
                print("Starting Phase 1 analysis...")
                # 분석 실행
                run_phase1_analysis_and_update_ui()
                # UI는 main 함수 마지막에서 일원화하여 rerun 함
        
        # 1단계 분석 완료 후 UI
        elif st.session_state.analysis_phase == "phase1_complete":
            if st.button("다른 아이디어 분석하기", key="new_idea"):
                restart_session(keep_messages=True)
                st.session_state.need_rerun = True
            
            # 추가 기능을 위한 버튼들
            col1, col2, col3 = st.columns(3)
            with col1:
                if st.button("2단계 분석 (준비중)", key="phase2", disabled=True):
                    pass
            with col2:
                if st.button("아이디어 저장 (준비중)", key="save_idea", disabled=True):
                    pass
            with col3:
                if st.button("결과 공유 (준비중)", key="share_result", disabled=True):
                    pass
        
        # 오류 발생시 UI
        elif st.session_state.analysis_phase == "phase1_error":
            if st.button("다시 시도하기", key="retry"):
                restart_session(keep_messages=True)
                st.session_state.need_rerun = True
            
            if st.button("처음부터 다시하기", key="restart"):
                restart_session(keep_messages=False)
                st.session_state.need_rerun = True
    
    # 필요한 경우 UI 리로드 (모든 변경사항 반영) - 일원화된 rerun 포인트
    if st.session_state.need_rerun:
        print("Need rerun flag detected, rerunning UI...")
        st.session_state.need_rerun = False
        st.rerun()

# 텍스트 데이터를 표시용으로 처리하는 함수
def process_text_for_display(text_data):
    """
    텍스트 데이터를 표시용으로 처리하는 함수
    
    Args:
        text_data: 처리할 텍스트 또는 데이터
        
    Returns:
        처리된 텍스트
    """
    # 텍스트 데이터가 문자열이 아닌 경우 문자열로 변환
    if not isinstance(text_data, str):
        text_data = str(text_data)
    
    return text_data

def add_message(role, content, avatar=None):
    """
    메시지를 세션 상태에 추가하는 통합 함수 (UI에 직접 표시하지 않음)
    
    Args:
        role (str): 메시지 역할 ('user', 'assistant')
        content (str): 메시지 내용
        avatar (str, optional): 아바타 이모지
    """
    # 디버깅 로그 추가
    print(f"Adding message - Role: {role}, Avatar: {avatar}, Content preview: {content[:50]}...")
    
    # 시스템 메시지는 중복 방지, 페르소나 응답은 항상 추가
    is_system_message = avatar in ["⚙️", "⚠️", "ℹ️"]
    
    # 중복 메시지 방지 (시스템 메시지만 중복 검사)
    if is_system_message and any(msg.get("role") == role and msg.get("content") == content for msg in st.session_state.messages):
        print("Message already exists in session_state.messages, skipping...")
        return
        
    # 메시지 세션 상태에 추가
    st.session_state.messages.append({
        "role": role,
        "content": content,
        "avatar": avatar
    })
    print(f"Message added, current message count: {len(st.session_state.messages)}")

def show_system_message(message_key, rerun=False):
    """
    시스템 안내 메시지를 세션 상태에 추가합니다
    
    Args:
        message_key (str): 메시지 키
        rerun (bool, optional): 메시지 추가 후 UI 업데이트 여부
    """
    # 안전하게 메시지 가져오기
    message_content = SYSTEM_MESSAGES.get(message_key)
    if message_content:
        # 디버깅 로그 추가
        print(f"Showing system message: {message_key} - {message_content[:50]}...")
        
        add_message("system", message_content, avatar="ℹ️")
        if rerun:
            st.rerun()
    else:
        print(f"경고: 시스템 메시지 키 '{message_key}'가 정의되지 않았습니다.")

if __name__ == "__main__":
    main()